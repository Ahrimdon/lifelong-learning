# What are the essential topics a programmer should become well educated in?

## Dima Korolev

How to eat healthy. How to maintain sleep schedule. How to exercise properly. How to to sit at the computer in an ergonomic fashion. How to find good books to read and good movies to watch. How to ensure people don't approach you asking to fix their computer or build them a website. How to deal with the opposite sex and not feel awkward.

## Adam Goldman

Treat every assignment as the stepping stone to become better. Learn how to learn. Treat yourself as a program you are writing. Analyze what makes you learn faster. Why that bug took you so much to solve. What strategy in your coding has allowed the conditions in which this bug "weaseled" it's way into your code?

Oh almost forgot the golden rule! Treat EVERY little opportunity to improve your coding as a TREASURE. Jump on it. DON'T WAIT FOR YOUR "BIG BREAK" TO BECOME A "GRAND MASTER PROGRAMMER." There are no big breaks. Only tiny bits of improvement, accumulated into bigger bits. This is actually true for every thing in life, but that's for a different answer :)

## Doug Hellinger

Disciplines: Test Driven Development, Version Control, Continuous Integration, Clean Code, Pomodoro Technique.

Principles: Lean Principles and KISS, Don't Repeat Yourself, The SOLID principles.

## Athulya Narayanan

Understand the underlying platform - mainly memory and speed. E.g - for an embedded programmer, it is very essential to write code that is optimized for memory usage and speed of execution. So, familiarize yourself with the underlying platform, so that you will be the most suitable programmer.

SDLC - Software Development Life Cycle - To be a good programmer, given a problem, one must be able to derive precise requirements, get a good design before beginning to code. Emphasis on the first two phases will save a lot of effort in the remaining phases of coding, testing and quality assurance.

Get a good understanding of machine level concepts - e.g in C, it is said to refrain from using 'goto'. But why? Because this can disrupt locality in cache. Hence, there is a reason behind every such theory when learning a language, which mostly is not explained to you. So, a bit of research when you hit a puzzling concept will go a long way, rather than taking everything given without questioning.

## Jacq Meyer

First in mind, a programmer should be good and have a clear understanding of mathematics. Algorithm for instance, it will be a plus if you have mathematics skills. Also logic for quick thinking and disposition. Also, you should style and understand your code. You know what they say "When it comes to your code, if you don't understand how it works, or doesn't work, no one will". Lastly, you also have to master strong sense of self-discipline to keep everything systematic.

## Anirudh Joshi

How to negotiate for a higher salary. Hiring new workers is very expensive, and your salary is totally arbitrary. Always ask for more money. You will get it, and if you don't, jump ship, because screw those guys. 

How to convince someone of doing something your way, without them noticing that it's your way.

How to build buffers into your projects. If you have RAM restrictions, malloc some space, and use that buffer at the end of the project to keep you on spec. If you have time restrictions, always triple your worst case estimates.

## Anuj Patel

- 1 : Debugging.
- 2 : Problem solving instead of specific technology.
- 3 : Always considering every possibility.
- 4 : Understand the problem and then code it, not the other way around.
- 5 : Always keep your hands dirty, nothing beats actual coding.
- 6 : Never be satisfied, your little code can always be improved.

# What advice would you give to a Computer Science major student that you wish you were given when you started Computer Science?

## Anonymous

Don't let other people intimidate you just because they've been doing this since they were six. Don't let other people make you feel like an idiot because you don't know something. Don't let other people convince you that your interests aren't good enough.

Listen to what other people have to say, and have an open mind, but don't let it get to you.

## Gene Spafford

1. Don't be hesitant about being curious.  Ask questions.  Try things.  Learn new ideas. Add new skills.  Don't ever stop asking "Why?" and "How?".  Take electives that aren't required.  It is important to learn your limits (and expand them), as well as learn what you do and don't like to do.  Don't avoid something because you think it is "too hard" until you've tried it for long enough to know for sure.

2. Become comfortable and proficient with human language.  Be comfortable reading and learning what you read.  Learn to write well — clearly, in an organized fashion, with good structure and imagery.  Learn to speak clearly and understandably, both in small groups and to an audience.  Consider getting involved with a student organization — student government, or a student ACM chapter, for instance.

3. Embrace problem solving and problem solving skills.  This means, in part, to not be afraid of math (especially finite math topics and number theory), but to cultivate your ability to think about how to solve problems.  Brain teasers and puzzles are good training — don't be discouraged if you don't solve them on the first — or 100th try.  Seek out opportunities to challenge yourself.

4. Cultivate patience.  Learn to be patient, careful, and persistent.  Programs don't often work on the first try, and if you are in a rush to code or test or fix them, you often make more work for yourself.   Some of my students have reported that hobbies such as sewing, glassblowing, model building, and so on all help to teach patience; others have had good luck with meditation, martial arts, and so on.  There is no "best path" but if you tend to be impatient, you should try to tame that.

5. Social interactions are important.  Learn how you best interact with others.  Polish your manners.  Bathe regularly (seriously a problem with some in the field!) and learn to do laundry.  Learn to smile.  Join a club, invite others to lunch, learn to ask questions of others (and LISTEN to the answers).  Btw, excessive drinking or drugs can seem more social but get in the way of several of the things I've listed here, as well as possibly disqualifying you from several career paths; being social doesn't mean bending to social pressure in every case.

6. Keep up with the field, and with the world.  Join the ACM, and the IEEE Computer Society (students get price breaks).  Read the literature that comes out about computing.  Get to recognize names of people in the field as well as up-and-coming companies.  Also, keep up with some news about the world, even if it only reading some of the headlines (at first).  Potential employers and colleagues may ask your opinion about things that are "big news" and a blank stare is not the best response.

7. Get a grounding in at least one other field: chemistry, aeronautics, statistics, criminology….  Consider a minor or even a second major.   It will enhance your job possibilities, as well as give you more opportunity to switch fields if you ever decide you want to leave computing.

## Kartik Ayyar

Do not expect you will be given much instruction about how to program in a CS school. Other than some basics, your professors will likely focus on concepts and leave implementation to be a self directed activity. If this bothers you, you are may not be cut out for CS.

Focus on taking the classes where you will learn the most. Never ever take classes based on how easy it is to get a grade in them. It is much more important to learn a lot than to worry about grades. The ideal scenario here is to take a class where you push yourself to learn, and still get great grades.

Always try to build a unified view of computer science various different classes that you take. Your Theory of Computation class can teach you something valuable for your Compilers class. Your algorithms class is related to your graphics class. Your graphics class is related to your linear algebra class. As and when there is an overlap of knowledge in different classes, use that overlap to your advantage to continually reinforce your learning. Pre conditions and post conditions you learn about in correctness proofs of programs map directly to asserts. Keep on collecting pieces of the puzzle and keep putting them together.

Do not sacrifice theoretical learning for implementation centric learning, and vice versa. They are both duals of each other, and not at odds with each other. If you sacrifice theory, it will deprive you of a much needed analytical framework to rigorously scrutinize the complexity of algorithms. If you sacrifice implementation, you might as well be a math major specializing in discrete math. Likewise, do not sacrifice depth for breadth or vice versa.

Your algorithms, OS and compiler classes will likely be your most important classes. Don't just stop at what your teacher tells you, be a sponge and absorb anything and everything you can learn about those topics. They will stand you in good stead for a long, long time.

Choose your collaborators and study partners well. They can really inculcate the right mindset for learning in you.

It helps to develop good relationships with your professors, on multiple fronts. It generally feels good to look back and reflect on how you didn't think of people that you learnt from with a sense of hostility. This is very important if you want to apply to graduate school, want to do research with a professor or have them help you publicize jobs for your company when you are later working in industry.

Not generic to CS, though it goes without saying that you should establish good friendships. Your college friendships will last a long time, and will be a social network as well as a professional network for a lifetime.

Spend time going the extra mile to learn about your OS.

At the end of the day, you should realize that a large part of your education is teaching you how to learn to learn rather than specific coursework.

Its tempting at times to write programs that satisfy your project requirement, and could get past TA grading, but won't meet the cut for a real program. e.g. its easy to leak memory in your assignments and get full credit for it, though try to push yourself to do a good job here and try to be a perfectionist in whatever code you do control.

## Rachel Fong

Start using git and shell ASAP. I know it doesn't seem important when TextEdit seems like it's all you could ever need for your standalone miniprojects, 17-year-old me, but you will deeply regret it when someone shows you a bash command a month into your first software internship that could have saved you ten minutes a day if only you'd known it existed. Or when you screw up your branch.

Pretend that, a year from now, you come back and need to refactor the code you are writing in the present day. Is it modular? Are your lines wider than your screen? What the hell is it doing? 

Whenever you find yourself turning down meaningful social opportunities to work on projects, STOP AND RE-EVALUATE YOUR LIFE. College is the easiest time to make friends; friends who will not only hang out with you, but in CS, will form an extremely valuable professional network in the future. You will have plenty of time to hole up in your basement at less exciting points in your life.

## Hitesh Sajnani

1. Buy your own domain name.
2. Install an Apache web server and configure it in a non-trivial way, e.g. to serve multiple domains.
3. Install WordPress and have your own blog. Write blog posts regularly. Write well. Good writing is a critical skill to master in this profession.
4. Run your own web site at home or in a hosting company.
5. Write at least one complete LAMP web app, preferably two — one where P=PHP, the other where P=Python.
6. Have your own [physical or virtual] server on the cloud.
7. Install VMWare or equivalent in order to boot up your laptop with more than one OS.
8. Configure your home DSL router so that you serve a web site or other kind of server from your home machine / laptop to your friends.
9. Use a packet sniffer to learn about the network requests your computer does to your favorite game server.
10. Write an app that uses at least one of the popular Web APIs, like Facebook Connect or one of Google’s.
11. Use Google AdSense on your web site, and make money just by virtue of attracting traffic.
12. Compile a complicated open source project from scratch, like OpenSim or Matterhorn.
13. Read works of literature and, besides enjoying the ride, pay close attention to how the author tells the story and makes use of words. Your programs should be as carefully written as those works of art! (Thanks, Beki!)
14. Get yourself involved in a software project where requirements are bound to change halfway through — that’s about 0.01% of homework projects and about 99.99% of real world projects, so find one of the latter kind. Finish the project with patience and the ability to take criticism in a constructive way. 
15. Write an application using map-reduce. Run it on Google app-engine or amazon EC2

## Artie Gold

Write code -- especially in an environment where someone has the opportunity to say, "That sucks. Try it this way instead..."

Remember that software is a little like being a professional athlete or a rock'n'roller: Unless you're one of the fortunate few, there will always be someone younger, cuter and cheaper coming up behind you. So make hay while the sun shines -- and have something else you love for when evening falls.

Truly understand Greenspun's Tenth Rule.

## Wouter van Oortmerssen

Ask yourself just how good of a programmer you're aiming to become.

If the answer is ambitious, the most amount of damage you can do to your developing programmer mind is to learn high level languages, api's and systems exclusively, only dipping down lower when absolutely necessary. Your rate of learning will forever be low, and have a low overall cap.

Similarly, you must aim to learn computer science and programming bottom up. even the highest level programming makes way more sense if you understand all the layers beneath it. Instead of a black box, it's like seeing a system in wire frame mode.

Better yet, there's less total concepts to learn this way. Assembly language is easy once you have studied computer architecture. C is easy once you have done assembly. C++ is easy once you have done C. most any mainstream language you will actually use day to day is easy once you have done C++.

In all cases it's all just a small layer over things you already know, and the clarity of understanding of even the highest level languages will be so much deeper, your code more solid, efficient and elegant. You need to have done those lower layers at least once in your life even if you never touch them again.

So, concretely, do a good computer architecture class early on, especially if it involves playing around with memory and caches in a (simulated) assembly language. Make C (not C++) your first real programming language. Try to understand everything that goes on in terms of memory (layout of things in memory, access and movement of data). Once fluent in C, bring on that compiler class. Maybe then learn C++ incrementally. Learn concurrency early on, distributed systems after.

Do not forget the high level topics, either. In particular, bend that von Neumann mind of yours with some Scheme, Haskell, ProLog or equivalent.

Besides the above, my second piece of advice would be to follow the idea of "Once and Only Once" religiously. It's the simplest and most universal guideline of how to create good code.

## Julie Haugh

Whether you call it "computer science" or "software engineering", it is important that you learn to think in a very clear and formal manner.  Don't leave the outcome to luck, and don't fix problems by slathering on more code.  You'd be surprised how often a better solution involving less code can be found.

Comments don't require CPU cycles or memory at run time (except for certain scripting languages, but I digress).  You will likely have to look at your own code again in a few years, so it is best if you comment your code heavily.  To make that less painful, learn to touch type well enough to get a job as a secretary.  Doing this will also help with that least pleasurable of all experiences -- writing comprehensive design documentation.

Programming languages are the tools of the trade.  You can cut down a tree with a nail file, but is it worth the effort?  You can cut your finger nails with a chain saw, but is it worth the risk?  There is nothing magical about any language.  There are those who swear by this language or that, but you should have enough programming languages in your tool bag that you have a choice.

## Hakon Verespej

My recommendation is to learn how to let go of the relentless focus on school and overachievement that you'll certainly face as you go through the program. Go for walks, meditate, whatever and give yourself a chance to really develop a deep understanding of yourself and who you are. Take courses you enjoy beyond computer science and expand your knowledge and appreciation of the broader world around you. It's easy to get caught up in the focus on academics and the hyper-competitive environment at many schools. There will always be someone out there who's better. Constantly chasing first place won't make you happy - it will just send you on a rarely-satisfying journey that never ends. Try to figure out what you want to get out of it and make that your goal. This can be difficult to narrow in on, so don't be shy of exploration.

Don't get me wrong - I'm not suggesting you blow off school or course work. Rather that it's important to find the right balance between the investment of energy in a focused area of study and exploring your interests and discovering yourself. Something interesting about computer science (and I imagine other subjects) is that you'll probably fall in love with it only after you find an area of the field or an application about which you are truly passionate. I've seen people who were bored with school and had sucky grades knock it out of the park when they started building video games.

## Anonymous

It honestly can't be reiterated enough: take, absorb, recall, and apply higher math. For the longest time, my CS education had me convinced that the end of the line was becoming a systems guru or specializing in low-level/embedded computation or even being a front-end designer. For the vast majority of students, this is perhaps an acceptable outcome and there's a good chance you'll lead a pretty decent career just sticking to any one of these. Here's a hard truth:

*You are excluded from the truly exciting and challenging work if you're not familiar with the necessary mathematics/statistics knowledge.*

No one in university sits down and explains to you just how ridiculously applicable so many concepts in math are and that their application is in fact facilitated by having a background in CS. Stochastic processes, dynamic programming, convex/nonconvex optimization, PDEs, lagrangians, linear algebra, regressions, monte carlo, random forests, Bayesian stats, supervised/unsupervised learning, and the list is practically endless (what I mentioned is really just what interests me!). If you don't understand the math, you made a mistake that you should do your best to correct asap.

A firm understanding of sophisticated mathematical techniques affords you an invaluable toolkit for approaching and tackling incredibly complex problems. Here's a secret: these are the people who are most employable, who probably most enjoy their day-to-day jobs, and who have opportunities to participate in incredibly lucrative careers (if that's your thing). And, it's never too late to adopt this mindset - there are resources freely available all over the place.

## Alexandru Iosup

*Produce and publish one piece of software about a topic that you care about. Try to convince a friend to join you.*

The topic can be anything you really care about. An online game about software engineers. A logistics tool for UNICEF. A database of birds for your dad who's a birdwatcher. A management program for your football or bridge club. Anything.

- Topic: Anything you really care about.
- Try to convince a friend to join you. Be helpful, supportive, and generous in giving credit.
- At least 600 hours/year.
- Productiion process, discuss it with anyone.
- Ship.
- Present the finished product to anyone who could become a user.
- Maintain your product for at least one more year.
- Start up! Get at least one good cx.

## Anonymous

Try to master a low level language like C and one high level language (like java or C#). In addition to that, you should learn a server side scripting language (like php or perl or python etc). This would give you an edge if you are developing web application. Learning javascript/Jquery would be an added advantage as it is the only client side scripting language.

As many people mentioned here, try to get a good internship. Industrial experience (in the domain you like) is always important for shaping up your career. For clearing interviews, you gotta be really good in data structures and algorithms. That's what many top companies expect.

Use linux extensively. There are 100's of distros available and choose the one you are comfortable with.

Finally, keep asking questions. Even if you write a trivial program, u should ask yourself..... Why have I written this program? ...How can I relate this program to a real world application?? ...Can I do better? (there should always be a better solution).

## Anonymous

You are going to work with people who mostly talk about nothing but computer science. When they are in a restaurant, they will talk about the latest mobile phone application that they developed. They live and breathe computer science. If you are not as passionate as they are, you will find it hard. Any notions of work life balance is generally frowned upon. Most companies will pitch you by saying "We are going to make you work your ass off but hey, we will pay you, give you free food and more importantly you get to learn so many things. We will even have hackathons so that after work, you can still code". The people who study computer science are among the smartest, so they will be really arrogant. You will hear things like "Just Google it" or "Have you tried the obvious solution". Obviously not all of them are like that, but a lot of them will be. People are less interesting and have inferior social skills. So, if your passion for computer science is so great that you can look past and maybe even appreciate some of the things I said above, then go for it. A recruiter once told me that you should be so passionate about what you so that you should have no problem working 12 hours a day. True story. You will work with some really smart people and watching the results of the code you write may feel like magic at times. It is just a question of what price you are willing to pay. I am a good student who has done internships at one of the big 5 tech companies, but I am not super passionate about coding. It is interesting, thats all. And I wish I had chosen another major. You will find it easier than others to get jobs and will get paid handsomely. In my opinion though, you are more likely to lead a very one dimensional life. Or you will not like it. All the best!

## GOOGLE from reddit

---- [begin excerpt] ----
Algorithm Complexity: You need to know Big-O. If you struggle with basic big-O complexity analysis, then you are almost guaranteed not to get hired.
Sorting: Know how to sort. Don't do bubble-sort. You should know the details of at least one n*log(n) sorting algorithm, preferably two (say, quicksort and merge sort). Merge sort can be highly useful in situations where quicksort is impractical, so take a look at it.
Hashtables: Arguably the single most important data structure known to mankind. You absolutely should know how they work. Be able to implement one using only arrays in your favorite language, in about the space of one interview.
Trees: Know about trees; basic tree construction, traversal and manipulation algorithms. Familiarise yourself with binary trees, n-ary trees, and trie-trees. Be familiar with at least one type of balanced binary tree, whether it's ared/black tree, a splay tree or an AVL tree, and know how it's implemented. Understand tree traversal algorithms: BFS and DFS, and know the difference between inorder, postorder and preorder.
Graphs: Graphs are really important at Google. There are 3 basic ways to represent a graph in memory (objects and pointers, matrix, and adjacency list); familiarize yourself with each representation and its pros & cons. You should know the basic graph traversal algorithms: breadth-first search and depth-first search. Know their computational complexity, their tradeoffs, and how to implement them in real code. If you get a chance, try to study up on fancier algorithms, such as Dijkstra and A*.
Other data structures: You should study up on as many other data structures and algorithms as possible. You should especially know about the most famous classes of NP-complete problems, such as traveling salesman and the knapsack problem, and be able to recognize them when an interviewer asks you them in disguise. Find out what NP-complete means.
Mathematics: Some interviewers ask basic discrete math questions. This is more prevalent at Google than at other companies because we are surrounded by counting problems, probability problems, and other Discrete Math 101 situations. Spend some time before the interview refreshing your memory on (or teaching yourself) the essentials of combinatorics and probability. You should be familiar with n-choose-k problems and their ilk – the more the better.
Operating Systems: Know about processes, threads and concurrency issues. Know about locks and mutexes and semaphores and monitors and how they work. Know about deadlock and livelock and how to avoid them. Know what resources a processes needs, and a thread needs, and how context switching works, and how it's initiated by the operating system and underlying hardware. Know a little about scheduling. The world is rapidly moving towards multi-core, so know the fundamentals of "modern" concurrency constructs.
Coding: You should know at least one programming language really well, and it should preferably be C, C++ or Java. C# is OK too, since it's pretty similar to Java. You will be expected to write some code in at least some of your interviews. You will be expected to know a fair amount of detail about your favorite programming language.
---- [end excerpt] -----
There were some other things that I felt like I was sort of expected to know that aren't mentioned above.
String algorithms, like Rabin-Karp substring search and the whole battery of algorithms that comes along with suffix trees (e.g., what's the longest palindromic substring?).
Dynamic programming problems. Backtracking problems (e.g., eight queens).
Mathematical tricks (e.g., choose uniformly random element from list without knowing its length; compute nth Fibonacci number in logarithmic time using matrix exponentiation, etc.).
Interval arithmetic (including interval trees and segment trees).
Heaps and priority queues.
Median-of-medians and the quickselect algorithm.
Linear-time majority element selection.
Bloom filters.
Regular expressions (be able to actually implement a pattern matcher for very simple regexes).
Object-oriented design.
Test-driven development.
Unix (e.g., are you proficient in a terminal, can you find the most common email in a log file with a one-liner, etc.).
Scaling the above algorithms to the point where their memory constraints are violated (e.g., sorting a list too big to contain in memory; finding the most common character in a string too big to contain in memory; etc.).
