# Things to Remember

- Root: `root 'controller#action'`
- To show errors: `get '/argh/:id' => :show_error`

# Routes

The triggering of a controller action is the main event in the life cycle of a connection to a Rails application. So it makes sense that the process by which Rails determines which controller and which action to execute must be very important. That process is embodied in the routing system.

## 2.1 The Two Purposes of Routing

#### Purposes of routing:
- Maps request to controller action methods.
- Enables paths and URLs for use as arguments to methods like `link_to` and `redirect_to`.

Each rule/route specifies a pattern which will be used both as a template for matching URLs and as a blueprint for creating them.

The generated patterns are based on REST conventions.

    get 'recipes/:ingredient' => "recipes#index"

- Static string: `recipes`
- Slash
- Segment key: `ingredient`
- Controller action mapping: `recipes#index`
- HTTP verb constraining method (`get`).

#### 2.2 The `routes.rb` File

The entire `routes.rb` file consists of a single call to the method draw of `Rails.application.routes`. If a given route fails to match, the matching routing falls through to the next one.

*Regular Route*

    get 'products/:id' => 'products#show'

*Constrainted Request Methods*

    match 'products/:id' => 'products#show', via: [:get, :post] #(can have via: :any)

*URL Patterns*

*The URLs that are generated by the routing system (via link_to and friends) only make sense to the routing system.* The routing rule then provides the necessary information to trigger a controller action. Someone looking at the URL without knowing the routing rules won’t know which controller and action the URL maps to.

You can do this: `link_to("Claim!", controller: "plates", action: "claim", id: 1)`, but it is more common to use *named routes*.

    get 'products/special' => 'products#show', special: 'true'

This means in order for you to match this route, you need to add a `special: true` var if you want to access it.

#### Spotlight on the :id Field

`:id` is not some magic. It is just a convention. It reflects the commonness of the case in which a given action needs access to a particular database record. The main business of the router is to determine the controller and action that will be executed.

The `:id` ends up in the `params` hash.

*Optional Segment Keys*

    match ':controller(/:action(/:id(.:format)))', via: :any

*Redirect Routes*

    get "/foo", to: redirect('/bar')
    get "/google", to: redirect('https://google.com/')

Blocks to convert the params

    match "/api/v1/:api",
    to: redirect { |params| "/api/v2/#{params[:api].pluralize}" }, via: :any

With status code

    redirect(status: 302) { |params| "/api/v2/#{params[:api].pluralize}" }

Segment Key Constraints: Show only on digits

    get ':controller/show/:id' => :show, constraints: {:id => /\d+/}
    get ':controller/show/:id' => :show_error

*The Format Segment*

    match ':controller(/:action(/:id(.:format)))', via: :any

This means we can have a `.json` request. And `params[:format]` will be set to `json`.

*`params[:format]` is special; it has an effect inside the controller action.* You can use `respond_to` for it:

    def show
        @product = Product.find(params[:id])
        respond_to do |format|
            format.html
            format.json { render json: @product.to_json } 
        end
    end

JSON has a code block: If JSON is requested, the block will be executed and the result of its execution will be returned to the client.

Unacceptable format: `406 Not Acceptable` status, to indicate that it can’t handle the request.

Just make sure that you explicitly tell any what to do with the request or have view templates corresponding to the formats you expect. Otherwise, you’ll get a `MissingTemplate` exception.

[TODO]
- Route Globbing 
- Routes as Rack Endpoints: We'll add this when we need Sinatra too.
