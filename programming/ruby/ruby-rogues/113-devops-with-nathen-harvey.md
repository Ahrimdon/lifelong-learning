TL, DR: WTF is this?

## 113 RR DevOps with Nathen Harvey

Picks:
- Jesse Storimer Unix class
- Mountain West Ruby Conference ‘Escalating Complexity: DevOps learnings from Air France 447’
- Hosted Chef, Learnchef.com
- Ruby and rails Coursers Roundtable
- The Phoenix Project (DevOps)
- The Ship Show podcast

NATHEN:  Alright. So, DevOps is a cultural and professional movement. It’s all about development and operations working together toward a common goal. And in fact, it goes beyond development and operations. It’s really about the entire business working together to deliver value to your customers. And the DevOps movement is really looking at leveraging ideas and processes from other industries, things like lean manufacturing. And we use DevOps practices and policies and this idea of DevOps to enable things like continuous delivery to enable agile development across the board, not just within the development team but also within your operations team and things like that.

JOSH:  That sounds really interesting. I use the word ‘DevOps’ and I’m being actually serious about this, this is not a joke. I use the word ‘DevOps’ to say the things that I do when I’m typing in the terminal when I’m not writing application code.

NATHEN:  You know, the thing that really made me both cry and laugh and shake my head and put my palm to my face was I saw a tweet awhile back about the Rails Devops Cheatsheet. And the Rails Devops Cheatsheet is, in fact, a bunch of Unix commands or Linux commands that do essentially that. They tell you how to do things like list all of the files in a directory, how to kill a process. These things are important. They’re definitely things that we should all know how to do but system administration or infrastructure engineering is not DevOps.

And I know that Dave, in particular, can sympathize with developers that find themselves binging their heads against the IT wall trying to get stuff done on their servers versus more of the — I’ve read a few books on XP and Agile where basically, you’ll have members on your team who are responsible for providing you with what it is you need, whether that’s direction or resources. And to have an IT resource on your team whether he’s using kind of a DevOps approach or whether he’s actually doing classical server administration for you, it just makes a huge difference to have that collaboration and some of the onboard that’s invested in your team because he’s a part of it.

NATHEN:  I think that the real change comes when you do start working together and try to have some empathy for one another and understand what’s going on. I think that traditionally, yes, operations absolutely look at development as the bull in that china shop. But I think that we start to see real change and real improvement when we start working together. Myself, as an operations person, I spent most of my — my first job in operations was sitting in the same room with the development team building out the product with them over time. And that is the right way to do things. And that definitely is the way to ensure that you can get to things like continuous delivery or something close to that, and really understand the problems that each other are facing.

NATHEN:  Maybe I’ll ask another question in response to it. I think there’s oftentimes a desire on the development side not to care about what the system architecture actually looks like. I don’t care what my deployment environment looks like. And I think that that definitely is the path towards destruction. When you’re developing an application, if you’re building it to run on something like Heroku, you’re going to build it slightly differently than you would, say if it’s running on Amazon’s EC2 or if it’s running within your own data center. And understanding some of the tradeoffs between those various architectural points is definitely an important thing that you have to bring in to your application design and into your application architecture.

NATHEN:  I think what you’ll find, and certainly coming from my Chef background, I use both Puppet and Chef professionally and obviously, now I work for Opscode, the company behind Chef. But I think that the real thing about Ruby and DevOps tools, it’s really no different than some of the reasons you came to Ruby. There’s a system administrator being able to automate things, number one, just makes me really happy. Being able to automate those things and use Ruby in order to do so, Ruby is all about developer happiness and I think that getting into Ruby in these automation tools like Chef, I just feel really, really comfortable in that space, I feel really happy, I can be very productive using Ruby. And I think that that’s really a big draw for Ruby and why Ruby is used so often when it comes to automating your infrastructure.

NATHEN:  Yeah. That’s definitely the case, that number one, you do have to think about things at so many different levels. And Ruby absolutely is a great way to abstract a lot of that away especially with meta-programming and things like DSLs, Domain Specific Languages. I can make a system administrator very comfortable managing not only a single server environment, but again, managing that entire infrastructure and managing that infrastructure as a cohesive unit not as a collection of a thousand different things.

NATHEN:  Because I don’t think that — I think that that’s an interesting take on it. I think that certainly, tools like Chef and Puppet came into the fore in Ruby in Rails and in that community through the things like Capistrano and whether or not they’re still maintained. But in any case, I think that it’s very comfortable for a Ruby developer to switch or to start implementing something like Chef or Puppet specifically Chef because the DSL is so comfortable there.

NATHEN:  I would say that when I first came to operations and was managing my first sort of Ruby or Rails application of Scale, I definitely started with Capistrano and was using Capistrano almost exclusively to manage that application.

The downside of tools like Capistrano is that in order to build in idempotence, you have to do a lot of stuff. You basically get that for free with Chef. And by idempotence, I mean things like if I want to, say install Nginx. I can easily write a script in Capistrano to build Nginx from source and install it on a server. The thing that I would then need to add in to se my Capistrano recipes is to check first to make sure that Nginx isn’t there, so that I don’t install Nginx every time I run that particular script. Whereas things like Chef, you get that built-in for free. It knows and it’s smart enough to know, is Nginx here? If so, I don’t need to take any action; otherwise, I do need to take action to make something happen. And what we really get into then is we’re modeling sort of the desired state of our infrastructure which is a slightly different way of approaching the problem. It definitely requires some mindset shifts than something like Capistrano where I’m just going to script. These are the steps I take to build this infrastructure.

JAMES:  That kind of leads me into an interesting side question. I don’t know if you saw recently, Nathen, this blog post by Chad Fowler on Immutable Deployments. But this isn’t the first time I’ve heard of this. Lots of people going to structures where when you build and deploy a server, then that’s it. And that server should never ever be changed again. So in other words, you would never re-Chef the server where it would need the idempotence feature. And then the idea is there, that if you need to deploy something else then bring up a new server, load your image on that or whatever with the changes and you put that in. And then, swap them out at the HAProxy level or whatever, your load balancer. Anyway, I was just wondering if you’ve heard of this kind of trend that seems to be — I’ve seen multiple people doing it now where a server is a one-time build thing and then if that needs to be done for any reason at all, then it’s totally replaced. I was wondering what you think about that.

I think that what we’ve learned in terms of system administration over the years is that golden images and essentially, that’s what we’re talking about here are golden images, aren’t necessarily a great way to manage your infrastructure. I think that you end up doing something like Netflix where you have to build a lot of overhead around how do I manage those golden images or how do I manage those AMIs and make sure that I can, in fact, get to a point where I have immutable servers.

But even in the example that you just gave, that HAProxy server is going to have to change. So, the configuration of which application server sits behind the load balancer, that’s going to change over time. And so, I think that it becomes challenging to sort out, what are some small changes that potentially need to be made and what is their impact on having things like golden images. So, in the case where I have a HAProxy server, if I need to change the configuration of which backend services is it proxing loads to, do I want to rebuild the golden image or do we build the machine every time I change like that needs to happen. And I would argue that you certainly don’t want to. You need to have something that’s a little bit more flexible. And that’s where something like Chef or Puppet comes in.

NATHEN:  I definitely agree of their value to the approach. And I think that it comes down to, how do you build those images? And something like Chef where you’re modeling your infrastructure, of course, you’re modeling it as code and it’s all in your GitHub repository or your git repository or whatever source code control you use. That also helps with auditability of what has changed on these servers over time, how have we been building out these AMIs. You can potentially give your Chef recipes with an explanation to your auditor and say, “Look, this is how bits get installed and configured on this server.” And this is the only way that those bits get installed and configured on this server.

NATHEN:  Yeah, that’s right. The Chef Server definitely — Chef basically utilizes a client server model where you have on each one of the servers that you’re managing or that are managed by Chef, they’re running the Chef client which will just connect to an API server. So, the Chef Server itself basically has a couple of roles. It is an API server that your Chef clients will connect to. It also includes a searchable index of data about your infrastructure. So, when we talk about things like the load balancer, you can query the Chef Server and ask it, “What application servers should I configure to be behind this load balancer?” Or in a Rails application, you could use a query against the Chef Server to determine, “How do I write out my database.yml?”

And then, the other thing that the Chef Server does is it provides essentially a publishing platform. So, locally on my workstation, I’ll write my cookbooks and recipes which are essentially the policy of the desired state of my infrastructure. And I will publish those up to the Chef Server and it will take care to distribute those recipes and cookbooks out to the nodes or the servers that are being managed that actually need to apply those policies.

And you’re absolutely right. The Chef Server itself was originally written in Ruby. And what Opscode has done over the past couple of years is we’ve launched a hosted Chef service where essentially, we’re running the server side of that architecture as software is a service. And what we saw in building that out in Ruby was that the API server really wasn’t scaling in a way that we wanted it to. And so, not only for our own needs in terms of hosted Chef, but also for some of our larger client needs.

So, we went about rewriting that entire API server or the entire Chef Server in Erlang. And what we’ve found with that was that we got incredible increases in performance and speed, much more consistent memory and CPU utilization, and just awesome huge rapid games there.

NATHEN:  I would say that one of the challenges that we do run into with folks is we are essentially asking system administrators to start modeling their infrastructure as code. And for a lot of system administrators, they feel like that is a huge step. They’re not programmers, or at least, they don’t view themselves as programmers. They’re used to writing Bash Scripts and things along those lines. So, coming to something like Chef can become a little bit scary for them. We tried to do our best and reassured them that they are in fact programmers, they just have really shitty tools. And so, we give them Chef and Ruby and that’s much, much better for them. And they can be much more happy there.

NATHEN:  Absolutely. I think that the really exciting thing in the Chef community over the last 18 to 24 months is a lot of tools are being built up around Chef, basically an ecosystem of tools around testing Chef. And this gives us things like unit testing through chefspec, TDD through Cucumber-chef and basically everything in between. And the beauty of this, of course, is we can start to build deployment pipelines just like you would build an applications deployment pipeline wherein I check in some code to my git repository that’s an infrastructure code change. Something like Jenkins or Travis CI can pick that up, execute my tests to make sure that my build is clean. And then, can push out those changes out to production and you can actually start to manage your infrastructure in the same way that you manage your applications.

NATHEN:  I think it really comes down to that communication. In some cases and in some environments, you simply can’t get out to the Internet. In that case, I need to either run my own gem server. In which case, I want to make sure I know what gems are on that server. But likely, that means I’m also running my own package repository because there are system level packages that I can get from vendors or that I can create on my own. And so, going to this idea of, now we’re complicated because we have some things that are gems that can be installed and some things that are packages that get installed and they don’t exactly work the same way. And so, how do we streamline that process and maybe packages is the right answer there.

NATHEN:  Yeah. It’s certainly easier now. But you also have tools like FPM. I don’t know if you guys are familiar with FPM. That’s a really interesting tool. I’ll give you a link for the show notes. But it stands for Effing Package Managers. It’s a nice little Ruby scripts that you can use to build a package for basically anything that you want. Well, I’ll put RPMs or DEBs based on what you want. And so, typically you’ll find folks are using that to build Ruby itself. I would never use something like RVM or rbenv in a production environment. I would have a package that is Ruby and that’s how Ruby gets installed on this machine.

JAMES:  I think you actually hit on something really key right there. I was involved in an application at one point where the client was asking for a very unusual feature. They were asking us, the developers, and it was going to be really complicated to implement and we were pushing back pretty hard because we didn’t think there was a big game for a development required. But it turned out, the ops guy, he basically did it by changing the web server config a little bit. He was able to get them basically what they want and it was a very simple thing to do.

And I think that’s what you’re hitting on right there is that, sometimes, things are very hard from one layer but not hard at all from the other layer. If you have all of these different services in a service-oriented architecture, and you need to handle some off globally across, maybe for third parties, one way to invent a complicated system that all of those services use programmatically that manages the [inaudible]. Another might be to put a proxy in there with some off-settings on it or something like that. There’s sometimes an easier way to skin the cat from the other side.

NATHEN:  Yeah. I think you hit on another great point there. And that is that there rarely is a single root cause. It’s always a bunch of highly improbable things that will never happen together, all happening at the same time.

JAMES:  You can read good books about how airplanes don’t crash because one thing goes wrong. We’ve made them so redundant and carefully balanced and monitored and everything. We have practices in place. Airplanes crash because ten things go wrong.

JOSH:  I have a question about process and team composition. When Elisabeth Hendrickson was on a couple of weeks ago and we were talking about the role of testing and exploratory testing in the application development process, she was big on, “Oh, you want to have people who are doing your testing involved very early in the process,” so they can have some input into the requirements or to look at the requirements and say whether they’re going to work or not. How early does it make sense to get ops people and DevOps type stuff going in the app development process? Do you want people there from the very beginning?

NATHEN:  I really think you do. I think that if one of your goals is to get to something like continuous delivery, then you really do need operations involved at the beginning. And there are tools out there, things like Vagrant that allow you to very easily spin up a development environment that’s going to look just your production environment. Let’s say you’re deploying to something like Ubuntu. Instead of developing on your Mac locally, developing a Vagrant VM that’s running Ubuntu that’s configured with something like Chef and we’re going to use the same recipes to configure your production environment, build out that delivery pipeline. Start with your Capistrano scripts. Day two, can I deploy to a staging environment? Deploying code should not be an exciting thing that happens only once every two weeks or once every six months or what have you. It should happen all the time.

NATHEN:  I think this is definitely going in the right direction. Not only are we seeing a prevalence of operations and dev working together a lot more, but I think that we’re also starting to see it in much larger companies. I think that you can now start to look at enterprises that are starting to embrace the idea of DevOps. And I do think that the way that they’re embracing the idea of DevOps is rather similar to the way that they embraced Agile when it first came out. So, there’s an edict from on high that ‘now we’re doing DevOps’ just like there was, at one point, ‘from now we’re doing Agile’. And so, you see some teams that have a standup everyday or that start to put an operations person in the room with the developers. That in and of itself doesn’t get you to DevOps or doesn’t get you to [inaudible] just standing up everyday.

But there are pockets within the enterprise or pockets within companies that are well-established that are starting to actually understand the ideas and adopt them properly. I think that we have a long way to go to really help people make the transition, help people start talking to one another, help people start looking at things across the value chain. But I definitely agree with you that we are getting better. The future is quite bright and we’re moving in the right directions.

NATHEN:  __For me, the thing that comes closest is a blog post that John Willis wrote on, it was actually on the Opscode Blog that defined DevOps as being about CAMS – Culture, Automation, Measurement, and Sharing.__ And he talks about things like people in process first and how do you automate things and so forth. I’ll put a link for that in the show notes as well.