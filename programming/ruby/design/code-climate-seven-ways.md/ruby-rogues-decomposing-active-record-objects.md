# 083 RR Decomposing Fat Models with Bryan Helmkamp
[Link](http://rubyrogues.com/083-rr-decomposing-fat-models-with-bryan-helmkamp/)

BRYAN: No. Those primarily came from just patterns, that in various forms, I’ve applied knowingly or unknowingly over the last — I don’t know, 5 years or so — doing Rails app development. I sat down and write it. And some of them kind of presented themselves and others were sort of refactorings that I’ve applied but I hadn’t really worked out exactly what the best way exactly to refer to it was or even thought through the trade-offs between the different patterns. So actually in writing the post, I kind of clarified for myself some of those different trade-offs and ins and outs about which patterns to use when and what the difference is between the different concepts.

CHUCK: So one of the things that I noticed — looking at the blog post here — one of the first things you said was, “Don’t extract mixins from fat models.” And it kind of made me think for a minute because it is something that… it is handy to do when you extract mixins from models, but it’s handy when it’s shared behavior. It’s not handy when you are taking one giant jump to making a whole bunch of little ones.

BRYAN: Yeah. I think that was one of the analogies I used in the post. It’s just the idea of pulling out bags of methods, I think people do it a lot of times just because it’s very easy. You know, you have an established a strong domain concept and you know, any of those methods can call other methods like it mixed in to the same class. So you are very unlikely to break things in the refactoring but you’ve kind of made it harder to see what’s going on and what the extracting the right concepts from that model would look like. So I think that’s the biggest problem is if you caught things the wrong way, then it can make it harder to be able to visualize how to cut things up in a better way.

DAVID: And there are a lot of Ruby programmers that tend to treat mixins like composition. That I’m mixing in this thing, so obviously I’m composing it. And no actually, you are not — you are inheriting. When you do include module, that’s in the freakin super chain — you can call super to get to those module methods. And so it’s a little subtle that people don’t realize that that’s inheritance guys.

AVDI: It means that you have in fact expanded your object’s API.

BRYAN: Yeah, that’s exactly right. And I know some people get hung up on the difference between inheriting from a class — like ActiveRecord base — versus including a set of functionality like I use MongoMapper and that’s based on an include.

BRYAN: You can do the same thing in a way. The only difference I think is just basically on how you’re communicating about the class is, right? Functionally, they do the same thing. You can say, “OK this class is a type that descends from this other type,” versus, it has an aspect of behavior which is this module. I don’t get too stressed about for libraries like ActiveRecord or DataMapper whether are inheriting or mixing things. I think that’s a debate that gets kind of blown out of proportion, but I think the key is to understand that inheritance in Ruby is basically the same thing as including things in Ruby and you have to treat it the same way, apply the same concepts.

BRYAN: Yeah, I think that’s right. You can use a mixin to patch together objects which are working together through composition.

DAVID: That’s… I’m sorry; I’m just sitting here kind of mind blown. Avdi, you mentioned that, “Hey you mix in a module and you just expanded your object’s API.” I’d never actually considered it that way, but holy freakin crap. Yeah.

AVDI: Yeah. I mean the way that I usually put it is you know, some people when confronted with a class that’s too big, think, “I will split this class into a class and five modules.” Now they have six problems.

CHUCK: So one other thing that I noticed  – and its very closely related to this — is that, of your seven strategies or patterns or whatever you wanna call them, I like strategies better personally but we can use the word pattern if we want. Five of them end in object and five of them are extract x object. One is introduce view object and the last one is extract decorators — and decorators are effectively another object that just had a different job. And so, I think it’s interesting when you are saying work with composition as opposed to inheritance. I mean, that’s really what we are doing here is we are composing these objects that do the job we need them to do.

KATRINA: I was wondering what are various heuristics that you used to recognize — for example that you need a value object. Like how do you recognize a value object that’s hiding in the big class or a service object — or policy object?

BRYAN: I think that’s a great question. You know, at the highest level one thing I do is look at the Code Climate scores for these things and to see, “OK looks like this ActiveRecord is getting pretty fat and the rating is getting pretty bad.” But more practically, once I’m diving into a class looking at it, there’s a few things and my favorite is to look for methods that have repeated words — in either as a suffix or prefix — that is usually a sure fire pointer that you are missing an object.

So if you’ve got methods in an ActiveRecord class that all end with underscore rating — so you know rating better than, rating greater than, rating from room mediation costs — those are some examples from the post then it’s really telling you want a class named rating. So that’s my favorite — by far – way   to recognize concepts. It’s actually something I love to do on Code Climate automatically in the future is detect like you got 30 methods in the class and 7 of them have the same prefix. Are you missing blank or blank whatever that prefix is?

BRYAN: One of the things about value objects that… probably one of my favorite refactorings and I think they are often overlooked in Rails apps and I read this post that kind of expanded my mind in thinking about value objects. It’s a little bit controversial, so if you indulge me. It was written by someone who used Java primarily and their point was, basically you can have a value object for everything, right? So if you have a name, you can have a name value object — you can have one for an address, you can have one for a rating and age – anything you want. And so the question is really like in what cases is that appropriate?

But there can be use in adding value objects for just a heck of a lot of primitive concepts in your application. And everything starts as generally starts as a primitive, right? You are creating a string column or a numeric column in your database and ActiveRecord pulls it out and you end up with a string or fixnum or a float in Ruby. But all of those are opportunities for introducing value objects. It’s just a question of which ones make sense. It sounds simple, but it really kind of expanded my mind in thinking about like, “OK, there are tons of applications to apply this. It’s just a matter of picking the right ones.”

CHUCK: Yeah it seems like in the case of like name and address, I mean, if you are just putting it in the database and then pulling it out to display, you don’t probably need one. It seems like especially in your example with the rating is that there is always behavior around it. That it does all these different things you know, it does comparisons that you know, it puts it out to a hash and all that stuff. So there’s value in putting that in there because it has some behavior on it whereas with name, I mean it’s just a string and that’s all that you’re using it for.

BRYAN: Yeah I think that’s right. I’m certainly not advocating that anybody create classes for all those different types of values. In the case of name for example, in the Code Climate code base, I do have a human name object and it is for splitting the name into different parts — so after the first name, the last name or the full name or the first name with the last initial – all of those things. So I think the interesting thing is just as soon as you start to hang behavior around a value, you can consider doing a value object.

And there actually tend to be pretty simple refactorings, because you can make them quack a lot like the primitives in Ruby. And you have the duck typing so it’s just works really well if you are defining like to_s then you can basically define the default representation for a person’s name in your application by way of the person name to_s method. And that will just work when you are interpolating that into your views. So that’s all what I was getting at there.

BRYAN: Yeah, that’s a great question. You know, I think for me, I would not want anything that is specific to the delivery mechanism to creep into value objects. So by “delivery mechanism”, I mean for most people it’s going to be your HTML concerns, right? But, in the case of the person name example, that is something that is used both on the web and in email. So that I think that’s a clear win for the value object.

But even if it wasn’t going to be used in email at all, even if it was only for the webpage, I think I would still prefer using a value object and encapsulating the behavior in the value object if that behavior does not have presentational concerns. So getting at the idea that I’m not crazy about helpers [laughs] I think they are useful for small bits of temple functionality. It’s just kind of why they were written, but they get abused a lot. And so I would look at encapsulating into a value object first for anything that is not presentation specific.

JOSH: The thing that I always run into around value objects is that when people start calling it a value object, I think that that sets up an expectation that it’s a passive piece of data. And that I mean the pattern… I don’t know if it’s a pattern or principle or what but using value objects, you are really thinking about these things as passive entities — they’re just repositories for state and you pass them around and other things figure out what to do at that state. And that can be, I think a great way to like loosen the coupling between pieces of code, but I think it can also get you in trouble in that it distributes the behavior related to that data in the various places that… and that putting that behavior into the value object’s class can… sometimes you wanna do that instead — and in fact a lot of times, you wanna do that instead, I find.

BRYAN: Yeah I think that’s right. You are saying by creating a value object, it allows you to centralize the behavior around that concept?

JOSH: Yeah, absolutely. And that’s like 80% of the reason why I create what people call value objects is a place to put that behavior. But I think when you call them “value objects” in like the GOOS’ approach to value objects, I think is very much they are just passive objects their state. I don’t know, maybe I got that wrong because I didn’t get the chance to read all of GOOS [chuckles] but am I off base there or is this… Is calling them value objects a way to trick people into not taking advantage of the behavioral aspect of them?

BRYAN: Well, I think that you know the value object distinction is primarily around the fact that they are usually immutable and their identity is sort of derived from the data that they are holding and not sort of an external system. So a property of value object is usually if you initialize two of them with the same variables, then they are usually going to be equal to each other. That’s a good distinction. But you know, I don’t think that it necessarily means that they can’t have behaviors I think you are just looking to create behaviors that are sort of fine-grained, like used in multiple places are kind of the things that… just like Ruby has a very rich set of value objects built into it, right? You’ve got everything in fixnum and string, and arrays which called multiple objects and they have all these behaviors that hang off of them and that’s Ruby is very general purpose. You can establish behaviors that are specific to your application domain and hang them off of value objects that are just in your app.

AVDI: So, can we talk about class methods?

AVDI: So why do Ruby class methods resist the refactoring anyway?

BRYAN: Yeah, so this is something that has come up for me a number of times over the years and I have had this discussion with programmers on the teams I have worked on and finally I was like, “You know what, I think I wanna clear up all my thoughts about this and put it on a blog post so I don’t have to keep remembering.” But the idea of the post is sort of ensure that class methods are global, and as a result of them being global, they tend to resist object-oriented approaches to decomposition.

There was a great comment thread on the post where people talked about doing functional decompositions of class methods — and that kind of work. If you are doing more of a functional style, then you are just going to be passing data down this chain to the different you know, decomposed functions in the finer, finer level of detail. But I usually prefer to start with a base where I can do object-oriented refactorings. And if you have your behaviour siting in a class method, you can’t do simple things like extract methods without starting to run into friction. You can’t use instance variables.

So the post was primarily response to people who might look classes, but don’t have any state and that only have one method and say, you know, “Why did he do that? You could have just written a class method.” And in some cases, I do use classes and I covered a few edge cases in the post, but generally the reason I gave you that is it just makes it a lot easier for me to see opportunities for refactoring and then take them, whereas if I have everything bunched up in a class method, it’s harder for me — at least when I’m looking at code — to extract those and decompose those. And I have seen anecdotally that on team’s behavior that starts simple in class methods general just becomes complicated class methods rather than getting pulled out and neatly decomposed.

AVDI: Yeah and you even sometimes see stuff where you know, they’ve started sort of simulating having instances, you know, classes might be start to keep track of the multiple sets of information or something like that. I actually saw an example of where this can go bad. Recently I have someone come to me a — pairing client — come to me and say, “I’ve got this redesign that I wanna do. Well, refactoring a redesign.” We have this program that we wrote as a one shot command line thing that would collate a bunch of data. I forgot if it sends out reports or what but you know, it’s a one-shot thing that it would run and then be done. And so it was written with a whole lot of class methods, a whole lot of class level data you know, so the classes had class instance variables. And it worked great as this command line program but they wanted to turn it into a – something that would sit persistent memory and periodically do this task that it was supposed to do.

So suddenly, you have this problem where you had classes with data specific to a single run and that data would just sit around and not be cleared out the next time it wanted to send stuff out because it’s siting there in memory. You know, if they had just created instances in the beginning, there wouldn’t have been an issue; it could have sat there in memory but each time it actually kicked off the batch job, it will just be starting up a new instance and it would create whatever instances. And so we went over various strategies for tackling it but it was one of those things where I probably wouldn’t have that pairing session to begin with if you know, the program had been written with instances in mind.

AVDI: If you are going to write just a straight line script without any abstraction to start with – which is a perfectly reasonable thing to do – write it like Perl and then stick a $ on front of everything. And then you know, that refactoring process is a little easier because you still have access to that variable. You can still just go through it one by one and start turning them into instance variable.

BRYAN: So variables with dollar signs are my favorite global variables. And the reason for that is it’s really freaking obvious they are global variables — so you can’t get that confused. On the other hand, you got things like class instance variables, class variables, their module equivalence — there’s a lot of different ways that you can have hidden global states in Ruby. So I love the dollar variables because it’s just like there’s no way to miss the fact that this is global variable towards the entire program. End of story.

AVDI: Well then there’s the constant that is always hiding in plain sight — the global that is hiding in plain sight which is the constant. Any name of a class or whatever.

CHUCK: So I don’t think we’ve taken this head on, but when is an appropriate time to use class methods or globals? Because it seems like class methods and globals are mostly the same thing just the scope is a little bit different.

JOSH: I think that the obvious use case for the class methods is factor to create instances.

BRYAN: Unless those factors get complicated, yes.

BRYAN: I was reading — new book recently and he talks about how Rubyists love factories, they just *hate* the word “factory” and all these factory things. But if anyone goes so far as to call it a factory — or god help you — put factory in a method name or a class name, everybody flips out.

DAVID: Yeah. Over here we call it builder. Over here we call it builder. Yeah.

JOSH: Yehuda wrote a blog post a couple of years ago that basically said Ruby classes are factories.

AVDI: Yup. Accurate.

JOSH: [chuckles] And that was basically the whole post. Bryan, do you wanna talk about some rule of thumb for noticing when your factory got complicated or is it just an exercise left to the reader?

BRYAN: You know, talking about if you have a factory implemented as a class method when it’s complicated and you wanna look at abstracting it out?

BRYAN: For me, that’s on the order of a few lines. Just for the same reason that I wrote the post about not using class methods for most things, I think I generally just use them to convert, maybe take an object and build up an instance with it by calling a few methods and passing state down. But as soon as you start to get into there’s any cyclomatic complexity, I think that would probably be one tipping point. So anything beyond just a few method and locations for me on this look at extracting into a class.

Now, I might keep a class method as a convenience. This is something I think I mentioned in a post a little bit that I don’t mind using class methods that are really just a short way to make it easier for programmers in the rest of the code to build up instances even if there is a factory that’s being used under the hood, but at that point they are really just sugar. So I think that use can be OK and you can have your cake and eat it too almost.

BRYAN: Yeah I mean you just don’t want anything to be fat is what it comes down to at the end of the day. I think what was meant by that anecdote is keep your controller layer thin and simple. Like, use your model layer to encapsulate all your domain options — which is right. And so in the end, you will have a lot more meaningful code in your model layer than in your controller layer but I think that you know, in passing, it almost sounds like what’s expected of you is to have ActiveRecord classes that are more than 500-lines long — which I think anyone who’s maintained apps that have those classes over long periods of time can tell you what callback hell feels like, at least. (I’ll work on being funnier next time too.)

BRYAN: Yeah. So this post, I just wanna call out, it was written by a fantastic guest post author named John Pignata who I have had the pleasure of working with in the past on a project — in a couple of projects actually — and he sort of distilled this kind of comparison between the way Unix is built and the way object-oriented system gets built into this post is great. So all of the credit goes to John on this one.

BRYAN: I’ll give you the take away. The take away is that creating small building blocks that have clean interfaces and have specific names where you are encapsulating functionality, gives you the foundation to start composing them in ways that weren’t originally intended. It’s just like you can pipe things together with bash on a Unix command line if you have objects which are decomposed and small and fine-grained, you can start to get that benefit of reuse in the small that it doesn’t work as well for re-use in very large cases but you can end up with classes that are actually reusable. And I think a lot of this is in Open/Closed Principle, which is one of my favorite object-oriented principle when I’m able to pull it off.

BRYAN: So the Open/Closed Principle says that objects should be closed for modification, but opened for in its extension. And basically it’s like you write a class, it does one thing, it does it well, so there’s not much of a need to go back in and modify the class later at all. You can create substitutes; you can extend that class and build more things on top of it. But once it does the job that you defined for it, why do we need to reopen it and go back and modify it 34 more times?

BRYAN: Yeah. And I would say that the simplest modification that you can make to an object — let’s take this rectangle for example — would be just adding a new piece of behavior like collision detection; that doesn’t change the behavior that’s already in there. You are just saying, “OK rectangles didn’t need this at the time, but collision detection is a core concept to rectangles in our system. We are going to add that.” And like Katrina said, it’s one change but it’s not going to 6 other methods that have been in the rectangle for the last three months and rewriting them for the 17th time.

AVDI: So when I think of the Open/Closed Principle, I usually think more in terms of objects that I can make my own extensions to easily without actually putting anything, without reopening a class or anything like that. One of the examples that I see a lot is the idea of callbacks. And not like heavy duty callbacks, where you tell some class, “Hey on this event, please do this,” but more like I guess internal callbacks. Like when you have a class who’s named go method, you know, primary method is follows the composed method pattern where it’s basically like just a series of method calls one after another.

You know, might be like the first one is like set up and then the next one is do some work and then the next one is tear down. And then I can inherit from that class. You know, it’s got its own setup and tear down and do some work methods but I can inherit from that class and I can just override any of those methods in my inherited class very simply. I don’t have to replace like that main go method in order to get my own stuff in there. If I wanna do a version that has a little extra set up, I can just inherit from it and replace the prepare method and nothing else.

BRYAN: That’s really interesting. I hadn’t thought about it in that sense so much. I think primarily because I don’t do a ton of inheritance. So I think it’s interesting because the principle is it should be closed for modification and open for extension and you know, usually extends is it will often kind of closely related to inheritance. But, I think that when I’m thinking about the Open/Closed Principle, it’s almost closed for modification and reusable in different ways. And sometimes that’s inheritance, but for me usually it’s not.

KATRINA: I find myself using the delegator or delegate from standard library a lot just to… I have one of the projects I am working on has 60 or 65 sort of base objects that are really tiny — they are all like instances of the same thing. And instead of having a PostGres database and ActiveRecord, I just kind of hardcoded 65 hashes. And then I used these objects and several different applications. And then these applications they might need a little bit of extra logic. Like in some of the applications, they do one type of work or back to doing work and setting up. And in other applications they’ll do other types of work and I’ll use delegate just to have the little object in sort of at the center of things and just delegate all of the usual things to that and just have 2 or 3 methods that do that custom stuff.

BRYAN: [laughs] Yeah so you know, one of the things that I just started kicking around today was writing a little bit about some of the functional core imperative shell stuff that’s been talked about a bit. You know, Gary Berndhart and Michael Feathers talked about that stuff, so I think I’m going to start kicking around some ideas for that sort of thing. I also like to cover some different ways to structure controllers that are maybe a little bit newer that people might explore to try to decompose their controller layer in a more factored way than what Rails kind of gives you out of the box kind as kind of an exploratory conversation. I have… I don’t know I have 30 sort of rough concepts in the queue, but yeah if people check out the Code Climate blog, then we are trying to beef up the posting on that so there should be some pretty regular stuff coming out just really along these lines. If you are interested in the intersection of object-oriented design, Ruby, Rails, all of that stuff, that’s where it will be.

Picks
- The Happiness Project
- 24pullrequests.com
- Brakeman
