## 067 RR Gary Bernhardt’s Testing Style
[link][http://rubyrogues.com/067-rr-gary-bernhardts-testing-style/]

GARY: Although, what I’m talking about when I say OO design usually there’s little resemblance to classical OO design or what Alan Kay would call OO design probably. Another big one, of course, is testing which historically I can talk mostly about isolated testing or closed isolated. Although recently I’ve been talking about things that are still isolated testing I guess, except not doing it in the traditional mock and stub way.

GARY: In that, I’m testing exactly one class with behavior and it’s not integrating with any others. But instead of using mocks and stubs, I basically just write it in a functional way. So it takes values in and recurrence values and that is a natural way to isolate code because, if the things that you’re passing in have no behavior, they’re just data. And the things that come out are just data and your testing only one class, you’re only executing only one class, then you’re not integrating with anything. You’re naturally isolated.

So I do that and then, that is the core of the program: its many classes that have fully functional behavior. They don’t mutate anything and they don’t call at any other classes. And around that is a thin layer of imperative code that does things like observe key stroke coming in and it evokes one of these functional classes, and then updates a reference that the imperative shell holds. So if you hit ‘J’, you could down a row in this Twitter client that I work on in that screencast. Hitting ‘J’ constructs a new version of the cursor that represents where which line we’re looking at and then updates the global reference to it. It’s not truly global, but conceptually global. So those are the 2 pieces: the functional core and the imperative shell.

CHUCK: When you talk about “isolating”, are you talking about just doing unit test and mocking up stuff that it just calls to? Kind of putting up stubs there so you know it call the right thing, or we’re actually talking about… we’ve talked about in other settings that like the fast test that Corey Haines does where you’re actually almost isolating from its dependencies as well.

GARY: The general rule, if I had to put a rule on it, is execute only one class that actually does something. It might integrate with a second class that just has data in it so it’s really just a struc. But only execute one class that actually does a thing. That’s not a hard and fast rule but if you had to give a rule that would be the one.

JOSH: I can see that if you impose some constraints on your testing style, that you’re not going to stub or mock, and that you only want to be testing small pieces of this system, I can see that that would be useful to help you achieve this. Is that what you do, you’re driving this from the test side?

GARY: I love all the good things that come out of isolated testing. And mostly those are, first of all the tests are very fast. And it also tends to give you very good feedback on the design. So if you’re stubbing or mocking every single thing you interact with then you look at that test and you see 6 mocks being set up at the top of it, you know that you’re collaborating with too many objects. But if you now replace those mocks and stubs with objects with data, you can get the same feedback because you’ll still have to construct all those things it interacts it. It’s just that now their values, which means that you don’t have this artificial boundary that you’re mocking. You have a real boundary which is actually on that class and their types.

DAVID: Connascence, basically the Litmus test is, what is the thing that has to change in order to break my test or break my code? And we’re mocking the crap out of everything right now because we’re dumb and we've actually got a data object… we have no idea what attributes this thing is going to have. So we’re mocking up this interface for it rather than going and defining the class. And it's starting to hurt. The thing is because we’re mocking, the real interface is actually decoupled from our tests. And I'm starting to feel pain from this because you could stand up the real system and all are specs would pass but that object doesn't exist yet. And so, I would be tempted to switch to a live object or some kind of a dumb object that at least imposes the same dynamic interface so that I could test it so that if the valid method or the save-it doesn't work, my test would actually reflect that.

GARY: So what you’re talking about there is more of faking, which is creating a secondary implementation that is simpler but does sort of the same thing like in memory storing instead of a database which is fine, but that mixes behavior and state and it’s much more difficult to do well than to either just stub the thing out. I mean it’s much more of locally difficult to create that correct state than it is to just immediately stub something out, or, to just construct a value and pass it in. And I think that constructing a value and passing it in and getting a value out has sort of all the benefits of both the stub and the fake. It’s easy to do but it also does not have that sort of… It’s not smashing over an interface and assuming that interface is there. IT IS the interface. There’s nothing to go out of sync there.

JAMES: It’s much closer to the GOOS’ idea of a value object than struct is. So Gary, one of the things in Destroy All Software kind of leading up to this screencast that I brought up is, you do a lot of episodes in my opinion on the back and forth of mocks. That’s actually what I love about watching Destroy All Software. You do a lot of mocking and stuff like that, but I think you did a really good job of showing the pain points of that, showing scenarios where that leads you into trouble and why it led you into trouble and trying to come up with rules where, “Okay. Here’s how you might that scenario.” or things like that. I got the impression watching and tell me if isn’t the case, but I got the impression that in all of that examining the good and bad of mocks, that’s kind of led you to this functional core-imperative shell to try that. Is that right?

GARY: I think that’s probably pretty fair first approximation of how I got there. Overtime, I’ve become more and more concerned with immutability, which also factors into that. Because the whole functional core does not mutate anything, it only constructs new values. But the problem with immutability is, in languages that are purely immutable like Haskell for example, it must be very difficult to do things like IO or basically anything stateful.

So that’s why Haskell is full of confusing things like the IO monad. But in Ruby, the IO monad doesn’t make a lot of sense to use. I don’t think because it is not statically enforced. So I’ve been thinking about this for years really, all the way back in the Python. How do you marry immutable data to the dynamic languages? You can’t exactly enforce that stuff, so you need to have some kind of division between mutation and not mutation that you understand that it is clear. And that is why I broke it into these 2 pieces, that’s exactly where that came from. The functional core is the code I want to write, and the imperative shell is the code I have to write in order to interface to the rest of the world.

The basic ideas are that you want to write functional code, code that doesn't mutate anything, because it is easier to understand and it's harder to make certain classes of mistakes. Theirs is no state mutate. Just create values, call function, new values come out. That's all that happens. I want to be able to write code that way because I can write better, more correct code more easily. But because this nasty world of networks and discs and humans, needs to interact with your code, you have to marry that functional stuff to it somehow. So that's the second piece. The first piece is the functional core which does all of the actual work, all the thinking and the program. And then the imperative shell does things like receive user input and call the functional code or take the values that come out of the functional code and update the screen from them. So it is the boundary between the functional code and the rest of the world.

JAMES: The screencast is done in Ruby. So like, to give you an example, it's a Twitter client and so like he said there's this functional core, this set of objects that talk to each other and behave but they’re functional. They’re immutable. They don't have side effects. And then the shell is almost like that the UI primarily that sits on top of it. And that it receives, you press this key on your keyboard, grabs that key and just passes it in to one of those functional methods. Or it wants to update the screen, so it calls one of those functional methods which returns like an array of lines that is actually what should be on the screen. So it clears the screen and creates those lines or whatever. And it's just sending data and employing data back out and then sending it to, like a reading from the keyboard, sending it to the screen or something like that.

AVDI: Excuse me. The thing that I’ve been wondering about is I’ve been a fan of making as much of the functions or methods in a program were immutable as possible for a long, long time. I used to like slap-const all over like everywhere on my C++ methods and stuff like that way back in the day. The one thing that does tend to show up when you do more of a functional style is, you wind up putting more complexity into the data structures that you pass from one function to another. And that can become somewhat constrictive overtime as you have a lot of methods that have intimate knowledge about what those value objects are expected to look like. It’s a sort of a real basic example from your screencast, you’re putting up, you’re dealing with an array of strings. An array of strings is a hugely complex data structure but there is kind of a line. In Ruby, there’s a lot there because array has quite a large API. A string has quite a large API. And one of the arguments for mocking and stubbing is that, it makes the API dependencies between you methods and the things your methods use is painful, very quickly. So the more dependencies that are there, the more your method knows about its collaborators, the more mocks and stub you sort of bloat up with. I’m curious if you have any thoughts on that. Is that a problem? The growth of, the knowledge of these data objects or is that sort of, for you, is that not an issue?

GARY: Well the functional folks would tell you that it is a benefit because traditionally, what functional programmers want to do is have an intelligent data structure as possible. Intelligent data structure is a term that they use positively. I’m still not entirely sure how I feel about this but, I will say that when I do lots of actual object interactions, I sometimes wish that I had sort of a transaction around it. Because when something wrong happens and I detect it, unrolling in the middle of that operation can be difficult. And one of the things that I noticed is that when you a transition a system from object interactions into values being passed around, you end up with values that are the transaction, which I think is sort of nice. And this is like the most obvious possible thing you could ever say to a functional programmer probably. But I really like that the large scale operations were represented by a single entity that was the operation. So, I think there are definitely benefits there and the functional guys are not dumb. They have reasons that they like intelligent data structures. I think the truth is somewhere in the middle which is why I’ve been programming with the 2 layers: the functional layer and then the imperative layer around it.

GARY: Yeah. I think that’s fair. Now I do, as soon as you start with that description, I totally remembered Greg’s post and he’s absolutely right. The whole fast test in Rails thing has been sort of a wedge with which we have driven isolation in to Rails programmers heads, but speed is not the best thing about it.  It’s nice to have fast test and it’s important to have fast feedback but the ultimate goal, the really important thing is the design of the system.

GARY: Well, to directly answer your question, I think I just used the Rich Hickey Method which is I'm smart and I can look at it and know whether it's right or not. [laughs] But the more general answer, I think, is that if it hadn't been a command line Twitter client, if it'd been a webout for example, I probably would have written some high-level tests, some integration tests to make sure that everything was working in a sane way. But I never, even though I didn't test that imperative shell, I never encountered a bug because of that. I would, but that was when I was cowboy-ing some code when I was spiking. But I never encountered a bug in any time other than when I was spiking code in the imperative shell and there's really only, I think 3 conditionals and they all fire like all the time. There's very little risk there. The other thing is I say this in a screencast that I keep the shell in the thick size. I think it's about 150 characters or 150 lines I say, something like that. And I’ll grow it to prototype new stuff but then once I prototyped it, I TDD it into an actual class. So the imperative shell is not growing and I don't know what happens when the program gets sufficiently large that 150 characters of the outside is noise compared to the size of it. I don't know what happens there, but for my fairly small program it's worked wonderfully which of course, the asterisks on like every programming argument ever.

JOSH: Yeah. And that's a segue into the thing that I wanted to ask you about next. So I've been reading the drafts of Sandy Metz’ coming out which is going to be phenomenal. And she makes a point that object oriented design is not about writing a little piece of software right now, it's about dealing with change that happens over the lifetime of the code base and spin yourself up with some foresight. So that when you need to change things, it won't be crazy.

GARY: That is certainly true for me, but one of my reasons for doing was watching the successes that it existed in the functional space with languages like Haskell where this is what they do. This is not one of your tools. This is their tool. The imperative shell is the way they build software and in Haskell, the imperative shell is the outer layer of the program that has IO on its types and that works. The problem that they run into is, as the program scales, it does get more difficult to reason about that. In the screencast, I think I actually mentioned at the end that a single shell is probably not the way to do this. What you want is components that are functional core-imperative shell and communicate with each other. So it’s a program of small programs which of course, is a thing that everyone has been advocating for program design since programs were a thing. So just because… sorry, go ahead.

JOSH: If you go like to smalltalk.org, they have history papers you can read. You know like Alan Kay’s writing about the original stuff. And they talked about the relationship of Smalltalk to the Actor model and then from there, you can learn how it evolved up into Erlang. It’s interesting how at its core, object orientation and functional programming are so similar and yet so different. We talked about this a bit recently when we had Michael feathers on and talking about if this is functional, but you are calling Erlang a functional language and that’s like a whole other conversation. But I find that, you know, people look at Erlang and they think it is functional and I look at it as extremely object oriented. I haven’t done a ton in Erlang and that’s probably not a fair way to think of it.

GARY: Erlang sort of embodies this distinction that we’ve been talking about the whole episode. Within a single running actor, it is a functional language. Functions call other functions, they return values with pattern-matching but between the processes, between the actors, that looks quite a bit like an OO system although they don’t have methods. Although, usually they re-implement methods in like every single Actor basically by doing tags to poles. Yeah, I think that Erlang sort of embodies it and it’s old. It’s not new. There’s nothing new about this. We’re just, as usual in this industry, rediscovering things over and over again and we think they’re new.

GARY: Although, I do have to say that what I’ve been advocating is good OO design for a few years now is really not OO. I mean when I advocate services and values as your primary design mechanisms, that is not OO. It’s not the OO that Alan Kay was talking about for sure, no more than C++ is.

JOSH: I think programming style is often much more interesting that the language that you’re programming in. And I said for a long time, although maybe not recently, that I can do object-oriented programming in almost any language. I can write object oriented code in assembly the language, by just controlling how I’m approaching problem.

JAMES: I would say that, Gary, the thing you’ve been showing over and over again with Destroy All Software, the whole services and values, maybe not traditional I would say it’s becoming the popular style of OO although, it’s very much advocated in GOOS. They call services, ‘services’ but it’s the same thing and they call value objects, ‘values’. They’re definitely using the same approach.

DAVID: I do have a question. Gary, do you ever run into a problem when you start your roundtrip? Where you pull this object from somewhere (but secretly we know it’s a database) and you modify it, which means you copy it, and then somebody else you hand it down the chain, they modify it and they copy it. Meanwhile, Janet has loaded the same object and she started modifying it. This is the central problem of Couch TV. At some point both of you are going to want to save your updated copy of that object. Does the whole thing fall apart at that point? Or do you have to have a really, really clever merge strategy, or what?

GARY: Well, let me answer your question with the description of a very hypothetical world, a world which may exist in certain Haskell programs. A controller in the MVC sense, is a function that takes an HTTP request and a state of the database and returns an HTTP response and a set of objects that were modified that should be written. And if you think of the top level in that way, assuming that the controller is your conceptual top level of program, then all the code you call can do whatever it wants and just keep returning, returning, returning new versions of database records. And then the level above the controller, which could be the imperative shell, can merge that into the database and commit them all. I don’t know if that actually answers your question, but that is one of the examples that I use because I think you think about mutating a thing and saving it. But really it’s a value that exists at the end of the request when the transactions committed, that’s when you want to change the database.

JAMES: There’s actually a really good series of episodes in Destroy All Software not too long back where Gary re-implemented Sucks/Rocks and as a Rails application. And it’s a really neat series to go watch for what you were just talking about David and that like; he goes a long time before he even introduces Rails at all. And when he does introduce Rails, finally it’s mainly as a persistence layer also as a display layer. But what he does with ActiveRecord’s really cool and that he only like defines 2 class methods on the model and they’re basically like, “Go get me this and go put this back in the database.“ And so like a beginning of a request he uses the “Go get me this.” and then at the end of the request, it’s like “Go get this back and go shove this back in the database.”, that kind of thing. It’s very interesting where you think about that.

JAMES: Yeah. It’s absolutely, I can’t recommend it enough. The amount of stuff I’ve learned from it. Gary talked a lot about his main threads in it but on his unit side, he shows show shell scripting which is just absolutely phenomenal. I’ve learned so many tricks from his shell scripting, Vim usage, I’m not even a Vim user and I enjoy watching that kind of stuff. Git, he shows a lot of things about Git especially if you want to get into messing around different going back through your history and finding out things about your repository and stuff like that. It’s very interesting. It’s very educational.

