# 172 RR Extreme Deployment with Badri Janakiraman and Florian Motlik
[link](http://rubyrogues.com/172-rr-extreme-deployment-with-badri-janakiraman-and-florian-motlik/)

BADRI:  Right. And when I heard [inaudible], when I first heard the term was how the phrase extreme programming came about is it was a concept of taking things that were understood to be good from a development perspective, and then turning them all the way up to 11 saying if they are good in small doses, why not just do them in large quantities? So, if code reviews are good for example, why don't we have constant code reviews by doing pairing? If testing your code is good, then why don't we do it all the time by doing automated unit testing?

BADRI:  No, well I was just going to say that yes, the organizational challenges are the biggest thing. The cultural challenges behind a movement like this are often the biggest hurdles to get over. And then after that, just before the processes, I find that application design is something that's really, really important as well. You need to design an application that is resilient to this nature of upgrades.

Because people are quite familiar with building applications that need to be released as monoliths and performing upgrades, both data and user functionality in large increments, and having to deal with data that’s just at one predictable state and then moving it one delta forward. And to build applications that are designed such that they are resilient, that they work when you deploy all the time, and users do not see any service interruptions, to be able to get to that point requires you to think about your application design quite a bit more as well.

JAMES:  I think GitHub uses a strategy along those lines where when they initially put features up, they make them available only to GitHub employees. So, as GitHub employees are going around and working, doing their work on GitHub, they’re using the next generation of GitHub, basically. And so, they get an internal testing from them and tweak there. And then eventually, the feature gets released to the general public.

We don’t do, the Snap production gate, the production pipeline goes through a staging environment. So, the staging environment always contains the next generation of Snap. And that is what builds Snap itself. So, we use our staging environment to build and deploy Snap. So in other words, we can’t promote our software into production if staging breaks for some reason. And staging has all the latest new features. So, it behooves us in order to fix the software to get staging up and running as soon as possible so all bugs are caught, or a good number of bugs that would have otherwise only been caught in production get caught. And we, the Snap team, are the only ones affected. And when we push it out there, there is less risk over there.

I think that starting with one small application on the side or one small part of your infrastructure, deploying that continuously, and then just growing that workflow into the rest of the company is a lot easier than the big bang release, or big bang change. Because otherwise, you’re just running up against people or people’s opinions, and that’s really hard if you don’t have the workflow and the experience there in place. So, it definitely goes hand in hand.

BADRI:  Yeah. And I found that starting with continuous integration and just testing is just a really, really good place. And once teams become familiar with just writing self-testing code and running continuous integration all the time and making sure that the code always get green and the tests are always passing, the rest of it seems to arise as a natural question saying, “Okay, now we seem to be getting our code such that it does not have any regression defects on a regular basis. What’s the next step we can take?”

And so, these just need to spread a lot more, so people really are aware of what’s out there. How can I do this? How are others doing it? How can I build a standardized way that makes it super easy to get started with small services, service-oriented architecture, and just immutability throughout my whole infrastructure? Each one of those might seem hard to implement. But when starting early with your application or starting small, they’re not that hard to get into your infrastructure and grow it in there. And then it’s just a matter of time until you have the technology in place and the processes before that in place that just make it super easy to just exchange anything, deploy anything new, just make deployment boring in that sense.

FLORIAN:  Yeah, I think that in terms of services, so when you have service-oriented architecture, it really needs to be separate services and dealt with as a separate service. So, if you need to deploy one of them, it needs to be able to deploy separately without deploying another one at the same time. So for example, that could be, if it’s an API, you just need to version the API. So, the old system at least for a while, when one of them is on the old one, one of them is on the new one, can coexist and call the other one at the same time. I think that’s something that, especially if you move to a workflow where you have small changes and you don’t do these huge releases so it’s rarely the point that you have to completely change your API and the interface between services, it becomes less of a problem in our experience.

But most of my ideas come from Steve Klabnik’s book, ‘Designing Hypermedia APIs’ I think. I’ll put a link in the show notes. But the main idea is there are certain rules that an API should follow. *And so, just to give an example one of those rules is ignore anything you don’t know. And this is how browsers work. If you have a new tag in the webpage and the browser has no idea what to do with it, it just throws it away.* And that means that on the browsers where they understand that tag, then it becomes what it becomes. And in the browsers where they don’t understand that tag, it just gets thrown away.

So, if you just use that one idea in your system of interdependent services, as long as they’re trained to ignore what they don’t know, then you can deploy one that has the new thing and the rest of the system should ignore that new thing for now. Then you deploy the other thing that uses the new thing that you deployed previously and that starts to kick things into motion.

## Database Migration Thingie

BADRI:  Exactly. There’s even a parallel to this in how people do database migrations for these sorts of systems, is it should always be permissible to find extra columns or extra data in the database without your application needing to break. So, from the client side, if you follow the protocol of ignoring anything that you don’t understand and from the server side, if you always started out with the aim of widening APIs first before narrowing them down, so then what you get to do is first you get to widen your API. Clients start to use the widened API but they don’t break.

DAVID:  Right. That actually was going to be my next question, is we talked about deploying two separate services. But I’ve done this in the past and I have an answer but we do this thing in the show format where we interview guests who know more than us. [Chuckles] So, I’m going to ask you guys. If you have a feature where let’s say in the customer’s table you’ve got a name field and it’s got first name and last name. And you’ve got a model that’s customer model and you want to migrate in the database to having a last name and a first name. And you want validations in Rails and you want validations in the database. The table, you want those columns to be marked as not null and then you want them indexed, et cetera. How do you release that so that’s in continuous and the site is never down?

BADRI:  That is the big kahuna version of this problem is when you’ve got to do addition and removal at the database level, you have to do it in a staged manner. And so, what you might do for this problem specifically is your object, your Rails Active Record Object for example would have a method called name in its public interface. So, at first step, you could start by providing a separate method which returns that exact same data which can then point to a different field in the database.

And then as a first step, you can add the first name and last name columns. And in that you can attempt to do a migration of the first name and last name. You can split that up. You can do the data population in there. But you don’t use those two fields to begin with. And this is the part of widening of the API so to speak, but this is widening of the data model before reducing its scope. So, once you widen the data model, you’ve got all the reads coming off of the old column and all the writes continuing to go into the old column.

And with the next deployment of the application, you can deploy probably a background service or a background job which every time the name gets written, it copies the name over into the first name and last name column. At this point, you don’t need to validate that those columns are not null or the Rails models validation don’t need to kick in because at this point, Rails is still writing to the old column and all the old logic can exist.

In the next version of the application, you can start reading from those new columns and continue writing to the old columns. And that way, your reads come out from the new data. And at this point, you still don’t need to do anything about the writes because the writes are still going into the old column.

And then in the last stage, once all your data has, you know that you can read through the new columns, you can start writing the logic to start writing into the new columns as well and eventually remove that background job which copies the data over from the old column to the new columns. And over a sequence of migrations, which if you are deploying multiple times a day can be almost as quick as just building the feature, you can make sure that neither the app nor the database are ever in conflict with each other.

BADRI:  But initially, when you’re just widening the data model, you don’t have to create the index. It’s only at the point where you start reading it that you need to create the index. So, things like that can get staggered as well. And you have a lot more flexibility. And you get to pick and choose at what point you want to put in things like constraints and indexes and validations rather than feeling like they all need to go in at the same time and somehow magically the system needs to work in its next version.

## When to SOA

FLORIAN:  Sure. We’ve all been there with the monolithic beasts that are just, we don’t understand them anymore. And we don’t understand all the models in there, all the classes in there, or how they really work together. And at some point, all the models, just everything, get entangled in that one big mess. So, we need to have more developers on there because it gets more complicated and more complicated. So, more developers come in, write more code that is even more entangled. And that just doesn’t scale in terms of the team. You might be able to make it scale on a technical level. But even that’s really hard if you have so much stuff in one thing, basically. But it just doesn’t scale on a team level. And especially not if you want to release quickly and all the time. If you want to release a lot of small changes to that big monolithic application, it just doesn’t work anymore.

And I think that there seems to be more and more push generally but also in the Rails community for a while, just to be able to do those microservices and service-oriented architecture and [inaudible]. So, in my opinion, that’s something that’s really hard to do from the beginning. But starting out with small services that just care about one specific task or a specific problem in your application and combining those services up into higher layers that really fulfill the whole application, that will be the dream. That’s still really hard to do because in the beginning it’s just so much easier to write the monolithic app, have all your models in there, all your controllers, all your logic in that one specific monolith.

So, we still need to evolve the technology and the processes that we have to be able to really do service-oriented stuff or microservices from the beginning. And I think that’s a big part where we need to learn a lot more. But then those large applications, you can’t use them if you want to deploy 50 times a day. That just… or you can use them but it’s really hard and really expensive and really painful.

SARON:  So, if it’s hard to start off with SOA, at what point should you make that transition or start thinking about that.

BADRI:  That’s a really interesting question. And I think it’s really hard to answer and I think this is where the monoliths get created, because very few people start out with a desire to build an unmaintainable monolith. But somehow along the way, the majority of people seem to get tripped up. And really, I personally do not have too much experience with it. But one thing I have found to be useful is a similar understanding to what we talked about when SOA was getting popular, is to break things along business boundaries.

JAMES:  One of the things that I would add to that is just to remember that you don’t have to get it right on the very first time. You can change your mind. So, I do work at a small to medium-sized company that does an SOA architecture. We have a pretty large deployment of services. And we did do SOA from the start, sort of, with a couple of caveats. And that was interesting. I’ve learned a ton about it. I’ve definitely not written about it enough, because I’m still figuring a lot of this stuff out and trying to decide what I know.

But the one thing I will say is that we do change our mind. At one point, we had this service and we thought we had very good reasons for putting these things in it. And then we tried it that way for a while and used it. And then we figured out more knowledge of what we were doing. And then we’re like, “Oh, this is actually some separate things. Let’s bust it up.” And so, we changed it and redeployed it. And the good thing is, in an SOA architecture, it’s usually not that… it’s less hard I think I should say, to bust the pieces up more or combine pieces, or shuffle them around. Because you’re generally working with smaller puzzle pieces than the overall picture.

## On QA

BADRI:  [Chuckles] You see? Because at the end of it, they are people too, and they are trying to do the best job they can. But if we work against each other then it doesn’t produce results. But if you make it easy for them to test then it works really well.

The other thing we’ve done is pairing with QA teams. So, if for example you write software, I’ll take a pathological example. If you put an element on a webpage that doesn’t have an id or a distinct class on it, then a tester can’t locate that with a testing tool in order to assert its value or presence or absence. That is a problem. If you plan to change the interaction of a page from being a full page reload to being an Ajax reload and you don’t tell your QA team how to do a wait for loop in order for an element to appear or disappear on the same page, that’s going to make their test be flaky and then somebody’s going to point at the QA team and say, “You wrote a flaky test,” when really we changed the logic when the developers change the logic from a full page reload to an Ajax load.

So, when you make these sorts of changes, pairing with the QA team in order to actually implement some of the things that they may not necessarily be experts at lends to an atmosphere of trust between the QAs and the developers. And that can go a long way towards building quality in into the software right from the start.
