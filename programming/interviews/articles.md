# How I Learned to Stop Worrying and Love the Job Hunt
[Reference](https://blog.stephanbehnke.com/how-i-learned-to-stop-worrying-and-love-the-job-hunt-in-toronto/)

- As part of my research I learned that most jobs are not found online, they can only be accessed through your network.
- No one replied re: sending out emails.
- Meetups + online community + recruiter + networking.
- Changes in the resume:
  - Highlight years of experience
  - Make it easy to see the skills section
  - Make sure each bullet point fits on a single line
  - Use colors to highlight different sections
- Hired.com works.
- Pre-screening: do your research, know what the company does, read their blog posts and explore their product, and use the "company expects these skills" and tell them you have those skills.
- Common questions:
  - Why us?
  - Tell me about yourself.
  - Biggest accomplishment?
  - Are you applying elsewhere?
  - Salary expectations?

## Lessons Learned

- Treat it like a sales pipeline.
- Talk to everyone.
- High-level matters. How to design systems, object relations, APIs.
- Side projects are not that helpful.
- Pick a stack.
- Be proud to talk about a project in depth.
- Leverage the opportunity to prepare. Have your code tools ready.
- Know complexity and scalability.

# What do people look for in an onsite pair coding interview?
[Reference](https://www.quora.com/What-do-people-look-for-in-an-onsite-pair-coding-interview)

- Workflow skill.
- Thinking out loud: how do you think about things?
- Programming skill + TDD.
- It's okay to make comments and recommendations to the workflow, but don't badmouth the decisions. Complaining without offering improvements is just whining.
- Type of developer: do we try things, or do we go Google things when we get stuck?
- Questions:
  - Do we have the basic skill we need to get the job done?
  - What gaps do you fill on the team?
  - Do I think you can get to speed quickly on the things you don't know? Do I have reservations about how long it's going to take you to be effective on the team?
  - Do I want to work with you every day?

# How do other senior software engineers prepare for coding interviews?
[Reference](https://www.quora.com/How-do-other-senior-software-engineers-prepare-for-coding-interviews)

- Seniors are very comfortable with systems design.
- Load and monitoring: load balancing, caching, indexes, and sharding.
- They know how to gather the right requirements, ask the right clarifying questions and decide what to do next with the answers.
- This is so we know a bit about how we scale things. Some requirements: are we dealing with structured or unstructured data? Is this going live to a set # of users or to the entire community? Is latency important?
- Ability to solve problems and showcase about how they came to a solution. When you are faced with a bottleneck, what are your options, and what can you do?
- ***Fundamentally, every bug is the result of an invalid assumption.***
- Simplest solution, then optimize for X, Y, or Z reasons.
- Being good at tech alone is never good enough. You need to be able to have logical discussions, apply theory, work with others, contribute, and be likeable.
- Articulating stories and answers to questions (both technical or non-technical).
- Fundamentals: hash tables, linked lists, BFS, DFS, sorting, arrays, dynamic arrays, search trees, dynamic programming, Big-O analysis.
- Practice on a whiteboard.
- There is no better way to interview than DS and algorithms. This is just the most efficient process to interview at scale.
- Imposing a forcing function: a gym is a gym.
- All the things you think about when coding:
  - Research, design, talk to the teams, scope, draft, implement, test, address code review, add metrics, deploy, monitor metrics.
  - Optimal algorithm, fault tolerance, variety of use cases, variety of inputs, dependency management, remote call error handling, data sync/data storage, unstable connection handling, usable/responsive/easy to navigate UI, cost of development/maintenance.
- So how do you do this:
  - No premature optimization: focus on the hardest aspects of functionality first, don't dive into all details at once.
  - Pipeline first: when done identifying the core and proposing solutions for it, don't rush implementing it or diving deeper.
  - Test your solution with a reasonable amount of valid and invalid inputs.
  - When implementing solutions, be clean.
  - Just do brute-force solutions first.
  - Apply all the things mentioned above.
- Things that you need to know:
  - Were you lying?
  - Were you actually doing good software development?
  - What are your actual limits?
