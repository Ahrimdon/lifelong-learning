## Why do you guys think Elixir is awesome?
[Reference](https://www.reddit.com/r/elixir/comments/7xnx1a/why_do_you_guys_think_elixir_is_awesome/)

- Easy to  follow, compiles to Erlang so fast/uptime/consistency. High testing/built in. Ecto, OTP, ETS for data. Phoenix makes writing REST APIs easy, especially web sockets.
- Rails = fast but it's hard to make it scalable/can be bug prone when you have to write a lot of tests. Functional so writing tests is a lot easier, and compiled so able to catch errors faster.
- No need for Redis, tooling to run async code, supervision, clustering, monitoring, brokering tools.
- Pattern matching. RabbitMQ is actually ran out of Erlang.
- Mix, Hex, pattern matching eliminates conditional code.
- Craftsmanship
  - Small core of strong utilities that allow you to create complex machines with few building blocks.
  - Macros allow you to express your solution in the language of the problem.
  - Accessibility to new developers, HexDocs. Ruby + Lisp.
  - It can define itself.
  - Tool wise, Elixir. Problem: releases.
  - Supervision model.
  - BEAM: designed to power long-running fault-tolerant scalable software systems.
  - Learning curve, faster test/edit cycles, enforced immutability, consistent idioms, many reasons listed in the thread.
- From Python/Django.
  - Mix just works re: packages.
  - Code generation via Mix.
  - Pattern matching: this allows me to write very precise definitions for when things should and shouldn't happen.
  - Supervisor, OTP.
  - Elixir community.
- The process model.
