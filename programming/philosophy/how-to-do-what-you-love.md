# How to Do What You Love & Earn What You’re Worth as a Programmer
[link](https://leanpub.com/dowhatyoulove/read)

University isn't about communication, teamwork, or project management. If you happen to learn those things, that's a bonus. To paraphrase Eric Beck, “At either end of the educational spectrum there lies a hacker class.” And we are not interested in hackers, even great hackers. We need those middle of the spectrum folks who are going to live in the suburbs, commute to our offices, and do a decent job for a fair wage week after week, year after year.

Quite honestly, the very fact that you passed on University tells us something disturbing about you. Quite obviously you aren't stupid. And you knew that people like us would have a problem with your lack of education. But you believed in your heart of hearts that you could make up for this with excellence.

Like hazing rituals and wearing dark suits to work in August, attending a certain kind of University is a statement that you want to belong, that you know there is no practical purpose to the exercise but that you are prepared to make the sacrifice just to fit in. And you, dear applicant, would not fit in.

It's not you, it's us. The plain fact is, you wouldn't be happy here. So buck up, look around, and see if you can get yourself into something a little more early stage. Consider starting your own company.

## No Disrespect

I hear an argument that business programming isn't hard. It does not require understanding combinatorial logic and fixed points. There is no value in knowing how to program in OCaml (or why that might be a good idea). Business programming is practical, and business programmers need practical training to do a practical job.

There is a culture of pretending business programming is more than it is. Some of you calling for more Java in University may take false hope that I am on your side. You may think that the people arguing for Scheme, Haskell, and OCaml are elitists. Wrong. They do not have a problem. You are the one with a problem because you don't want to tell all your friends you have a job as a clerk.

If a Computer Science degree was really meant to give you an advantage in a business environment, it would involve a lot more writing English than writing Java. You would know that if you went on to get an MBA.

Let me tell you, and I speak as a hiring manager. We lie to you. We write in articles and books and on blogs how much we value a degree. Joel Spolsky argues that there ought to be good degrees. But I will bet anyone $100 that he will hire a high school graduate if that graduate is smart and can get things done.

Beyond your actual ability to write programs, a degree is only as meaningful as its scarcity. If degrees are easy to get, they mean squat. Sure, when I'm hiring I might choose to toss all the no-experience resumes without degrees. I'm still left with a pile of two hundred people to interview. Do you think I'm paying any of you top dollar when I have 199 more people to see?

*The reality is that your degree is only a pacifier, a way to make you feel good about yourself. The industry is selling you the illusion of respect.*

You can be respected for your job. But it has nothing to do with whether we pretend a university degree is required for the position. Everybody knows it isn't: if it was, there would be no need to dumb down the program to suit the job. Respect comes from what you accomplish, and where programs are involved, it comes from writing programs, not from a title or a piece of a paper (nor from a book or a blog). Nobody on Earth can stop you from writing software and earning genuine respect.

## Interlude: You and Your Research

In order to get at you individually, I must talk in the first person. I have to get you to drop modesty and say to yourself, “Yes, I would like to do first-class work.’’ Our society frowns on people who set out to do really good work. You’re not supposed to; luck is supposed to descend on you and you do great things by chance. Well, that’s a kind of dumb thing to say. I say, why shouldn’t you set out to do something significant. You don’t have to tell other people, but shouldn’t you say to yourself, “Yes, I would like to do something significant.’’

Over on the other side of the dining hall was a chemistry table. I had worked with one of the fellows, Dave McCall; furthermore he was courting our secretary at the time. I went over and said, “Do you mind if I join you?’’ They can’t say no, so I started eating with them for a while. And I started asking, “What are the important problems of your field?’’ And after a week or so, “What important problems are you working on?’’ And after some more time I came in one day and said, “If what you are doing is not important, and if you don’t think it is going to lead to something important, why are you at Bell Labs working on it?’’ I wasn’t welcomed after that; I had to find somebody else to eat with! That was in the spring.

## How to get your first job developing software

In my experience, good developers love to write code. In fact, the very best developers don’t know how to “not write code”. When they were in high school, they wrote MUDs in Basic (well, that’s what they did in the 80s). When they were in college, they developed Perl and Tcl scripts that scanned Usenet for updates to threads of interest. Even if they hold a “lowly” summer job working in a computer store, they have a Linux system at home running Apache and mod_perl or PHP.

Even after they get paying jobs working 70 hours a week, good developers can’t stop coding. For example, Phil Greenspun started Ars Digita, yet he wrote lots of free tools on his home server (I use two of them on my own weblog). Paul Graham ran Franz and Viaweb (now Yahoo! Stores), yet he is busy developing a new language, Arc. In my own case, I was busy as a consultant in the early nineties but couldn’t help writing a PDA application and a dynamic web service “on the side”.

When I am asked how an inexperienced person can get their foot in the door, I give two pieces of advice:

First, I tell them to just start writing code. If they don’t know what to write, I don’t suggest anything specific, I just tell them that they should pick stuff they enjoy, using tools they like. It isn’t important to use the latest “industry standard” tools or work on something “commercial”.

Second, I tell them to think in terms of a “portfolio” instead of a “résumé”. Even if they don’t take a physical portfolio to job interviews, their résumé or cover letter should include an appendix with samples of their work. If an inexperienced person wants to stand out from the crowd, screen shots, links, and code snippets will appeal to a technical hiring manager.

Is any of this guaranteed? No. Some companies hire HR people that are not qualified to tell the difference between a talented candidate who compiles and builds their own development environment at home and a mediocre college graduate that didn’t expand their own horizons.

I personally wouldn’t want to work for a company that gives significant authority over its intellectual property to such an HR person, but not everyone is as picky as I am :-)

## The single most important thing you must do to improve your programming career

*The single most important thing you must do to improve your programming career is improve your ability to communicate.*

To program, you must elicit ideas from other people and share your ideas with them. Sharing ideas comes in many forms: explaining how you did something. Suggesting a new practice for the team. Demonstrating how something works. Convincing everyone to switch programming languages. Persuading a brilliant engineer to join your team. Persuading your manager to get out of the way and let you do your thing.

Advancing your career is entirely about communicating. Getting a job. Turning down a job. Asking for a promotion. Turning down a promotion. Getting onto a good team. Politely extricating yourself from a good team. Persuading a brilliant engineer to co-found a company. Helping a brilliant engineer understand why co-founding a company isn’t the right thing to do. Asking for funding. Turning down funding. Getting clients. Turning down clients.

It’s all communication. Now you know, I have a background in Sales and Marketing. So I worry that I am holding a Golden Hammer and suggesting to you that your career is all about nailing things. But here is the short and obvious truth: Human beings are all about physical communication. It’s a huge, huge part of what makes us human, this talking and listening jibber-jabbering thing.

Frankly, there is no substitute for actual speech with visible body language. We do not react to the written word the same way that we react to a speech where we can see the speaker. So let’s skip right past learning to write well. It’s phenomenally important, but learning to speak well trumps everything. Where I work, we talk about technical things all the time, and the remote members of the team switch out of Campfire into iChat or Skype to hear each other’s voices and see each other’s faces at least once a day.

If you take just one thing from this post, let it be this: To improve your programming career, the single most important thing you must do is improve your ability to communicate your ideas face to face.

Here is what to do today to shorten the line between where you are and where you need to be: Volunteer to give a presentation that you can entirely control, and invest the time and effort to do the best possible job.

## The Mother of All Interview Questions

*Does your process involve invention? If so, please describe the three most recent things you have invented and why it was necessary to invent something new.*

The results are really easy to interpret. Does your team invent new things in the course of its work? If so, what are you to make of a candidate who doesn't invent new things and believes that software should be built by integrating tried and true existing components? Such a candidate is not wrong, but are they a good fit?

Even if you invent and the candidate invents, discussing their inventions drives directly to the core of what kind of developer they are. Are their inventions part of the core value proposition of the software they develop? Are their inventions focused on developer productivity but invisible to users and stakeholders? Do they prefer novelty to reliability?

Such developers have realized that if you never invent, your code cannot be better than anybody else's. This might be fine for some internal HR workflow management application, but when building anything that is part of their employer's core value proposition, you cannot add great, disruptive value without being prepared to take the road less traveled somewhere in the code base.

I will not suggest that one or the other approach is the best way forward. I think that for each person, there is a natural affinity to invention or a natural dislike of the risks and time sinks involved. Some people feel deeply rewarded giving birth to something new after a long, arduous period of research, trial and error. These developers can often be insanely smart.

## My Favorite Interview Question

The question they asked was: How might you design a program that moderates or referees people playing Monopoly on the Internet?

Monopoly is poorly defined. The official rules of Monopoly are silent on some critical questions and vague on others. This problem makes it a great interview question. It drives a lot of valuable interactions between the candidate and the interviewers. You have to ask questions, make assumptions, and know when to stop gathering requirements and start driving the design.

This ‘problem’ makes it a great interview question. It drives a lot of valuable interaction between the candidate and the interviewers. You have to ask questions, make assumptions, and know when to stop gathering requirements and start driving the design.

*If the candidate uses up all of the interview time trying to obtain perfect requirements, we have a problem. In the software development I do, the requirements are never perfect. I don't demand that a candidate try to create an agile, iterative process on the spot, but I look for someone who knows when to say “close enough, let’s move forward.”*

The second reason I like this problem is that Monopoly requires more than just a simplistic object design. Competent software developers spend much more time on relationships, responsibilities, and constraints than they do on trying to prematurely optimize reuse through inheritance.

Where do the rules live? In a noun-oriented design, the rules are smooshed and smeared across the design, because every single object is responsible for knowing everything about everything that it can ‘do’. All the verbs are glued to the nouns as methods.

Let’s take a look at a simple rules question. If a player owns Baltic Avenue, can she add a house to it?

Well, there’s a bunch of stuff about whether she can afford it and whether there is a house available in the bank. Where does that live? In the bank object? And there is a bunch of stuff about whether it is either the player’s turn or between turns. Where does that live?

And there is a bunch of stuff about whether the property already has four houses. Where does that live? Somewhere in the property hierarchy? Sounds reasonable. Now what about mortgaged property? If Baltic is mortgaged, the answer is no. That’s easy. But what if Mediterranean Avenue is mortgaged? And what if, for example, Baltic has one house but Mediterranean has none? Where does that logic live? Both of these last two questions involve knowing something about the other properties of a colour group.

Now you can debate which verbs belong to which nouns, but here is an opportunity to step back a bit and consider the larger implications of maintaining such a ‘classical’ OO design.

OO programs can be brilliant communicators in some designs (“here’s everything I need to know about a Money Transfer”) and terrible in others. I think this is part of the appeal and effectiveness) of the Domain Specific Language approach. It does a better job of communicating its intentions than a simple OO design.

Another issue about the rules. In software development, requirements often change. What kinds of requirements changes are easy with the design? What kinds are difficult?

Now to close as rapidly as possible with what I consider an essential characteristic of a good design problem, and one that applies here. Monopoly is too large to solve in one interview. *The reason this is important is that it forces the designer to pick and choose what elements of the design to solve in limited time.*

## Interlude: Idiocracy

*Never hire an engineer on the basis of questions any idiot could answer. If you ignore the above maxim, the result of your negligence may one day wind up becoming your boss. If you take a job with a company that asks you questions any idiot could answer, sooner or later they’re going to put you on a project with some idiot who answered them.*

## Take control of your interview

*bjective: Think of three things you want the interviewer to know about you that you think they are unlikely to find out if they ask all the questions.*


The important ideas are that (a) you want the interviewer to know about each of the three things, and that (b) the interviewer is unlikely to ask about all three if you don't exercise some control over the interview.

First, don’t bother with how many years of technical experience you have with the company’s tools and platforms. If they are using in-house Common Lisp macros compiled to C and then distributed on a grid with MapReduce, I guarantee that they will ask whether you have any Lisp or distributed programming experience all by themselves.

The three things you want to take into the interview should be stuff that matters to them but is hard for them to ask about. Think about the difference between yourself, presumably an expert in these areas, and someone who has only worked on one project with the same technology. You both touched all the same tools and code, but there’s something special about you, your extra experience means something. What is it?

If you tell me that you have five years of experience, I have no idea whether you have five years of experience or whether you simply did the same thing over and over again. What is it that you learned that makes you special? What secrets to you possess that can't be listed on your resumé?

For each person, there will be different answers. One person might say that their “secret sauce” is that they have learned the ins and outs of the platform, they know what works and what doesn't, they know how to work around the shortcomings. Another might emphasize the non-technical skills. I would personally be impressed with anyone who said that what makes them special is that they are very, very accurate when they estimate tasks and projects.

Interviewer: What's your experience with Ruby?

Interviewee: Well, I was the lead developer on the Certitude project. We built that with Rails and we included a fairly heavy dose of Ruby idioms, including a domain-specific language for pattern-matching and lots of dynamic meta-programming (answers the interviewer's question). One of the things I discovered on that project was the importance of a bomb-proof quality control process when you have such a powerful language. I customized our continuous integration server to track changed files, tests, bugs in a unified report interface so we could monitor the most troublesome modules. It really saved our bacon late in the project when we had to really tighten up our risk management to ship on time (the add on, emphasizing the process).

Perhaps you didn't get a good opportunity to mention your three things and the interview is winding down to a close. Don't try a desperation coat tail where you try to stick two completely unrelated things together. Instead, try using a question to introduce one of your things indirectly.

## So here's how to get started:

- List your three things you want the interviewer to know about you that you think they are unlikely to find out if they ask all the questions;
- Write a one-paragraph description of for each thing that you could use to ‘coat tail’ onto another question;
- Think of a question you could ask for each thing that would naturally lead to a discussion.
