# You don’t understand your software engineers
[Reference](https://medium.com/@amandoabreu/you-dont-understand-your-software-engineers-53442ca0805a)

- Developers are self-motivated people.
- Majority code outside of work hours as a hobby.
- When shifting your attention between contexts, you can lose up to half a day to get back to where you were.
- Work environments should not foster distractions. If he knows that he won't be able to focus on the task, he probably won't even start.
- Solutions: flexible schedule, home office.

## Comments

- *Trust is requirement #1 for this job (software development).*
- Solo work without distractions, one-on-one collaboration, group collaboration, collaboration with stakeholders, space to get out of your head, etc. Mechanics, chefs, carpenters, etc. work in places designed for and dedicated to their type of work. So should developers.

# Why Entrepreneurs Start Companies Rather Than Join Them
[Reference](https://steveblank.com/2018/04/11/why-entrepreneurs-start-companies-rather-than-join-them/)

- *Entrepreneurs start their own companies because existing companies don’t value the skills that don’t fit on a resume.*
- Signaling: When you look for a job, you signal your ability to employers via a resume with a list of your educational qualifications and work history.
- Capable: If they think they are more capable than their employers.
- Better pay.
- Less predictable pay.
- Smarter.
- Immigrants/funding: harder to show their credibility to existing companies.
- ***Asymmetric information about ability leads existing companies to employ only "lemons," relatively unproductive workers. The talented and more productive choose entrepreneurship.***

# The melting pot of JavaScript
[Reference](https://increment.com/development/the-melting-pot-of-javascript)

- Unconstrained by a single vendor, the JavaScript ecosystem closely reflects human culture. It is inventive, incremental, messy, assimilating everything on its way, and ubiquitous.
- Traditionally, software platforms had gatekeepers (Apple, MS.) They provided a language, a compiler, and a set of SDKs.
- Because of innovations in the browser, JS made rich client-side apps possible. Node, module system. The authors of the JS SDK: app developers who learned about parsers, source code manipulation, static analysis, optimization. Tool building in JS became common.
- Unix philosophy: simple programs meant to be chained together. In my experience, the order and manner they are wired together are crucial. You need to learn their internals.
- ***Your App Makes Me Fat: "If your UX asks the user to make choices, for example, even if those choices are both clear and useful, the act of deciding is a cognitive drain. And not just while they’re deciding. … Even after we choose, an unconscious cognitive background thread is slowly consuming/leaking resources, “Was that the right choice?” … If our work drains a user’s cognitive resources, what does he lose? What else could he have done with those scarce, precious, easily-depleted resources? Maybe he’s trying to stick with that diet. Or practice guitar. Or play with his kids."***
- This is why we need good error messages and our config options need to be useful for many people.

## My Take

- Config should not stand in the way of getting started.
- Resist adding more configuration than absolutely necessary.
- Disclose advanced features progressively.
- Mind your output.
- Create reusable toolboxes.
- Toolboxes, not boilerplate. It should work with no configuration.

- Even if you are not a tool maker, you just need to make error messages that are not obscure, and have reasonable defaults for config options.
